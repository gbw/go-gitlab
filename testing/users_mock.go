// Code generated by MockGen. DO NOT EDIT.
// Source: gitlab.com/gitlab-org/api/client-go (interfaces: UsersServiceInterface)
//
// Generated by this command:
//
//	mockgen -typed -destination=users_mock.go -package=testing gitlab.com/gitlab-org/api/client-go UsersServiceInterface
//

// Package testing is a generated GoMock package.
package testing

import (
	io "io"
	reflect "reflect"

	gitlab "gitlab.com/gitlab-org/api/client-go"
	gomock "go.uber.org/mock/gomock"
)

// MockUsersServiceInterface is a mock of UsersServiceInterface interface.
type MockUsersServiceInterface struct {
	ctrl     *gomock.Controller
	recorder *MockUsersServiceInterfaceMockRecorder
	isgomock struct{}
}

// MockUsersServiceInterfaceMockRecorder is the mock recorder for MockUsersServiceInterface.
type MockUsersServiceInterfaceMockRecorder struct {
	mock *MockUsersServiceInterface
}

// NewMockUsersServiceInterface creates a new mock instance.
func NewMockUsersServiceInterface(ctrl *gomock.Controller) *MockUsersServiceInterface {
	mock := &MockUsersServiceInterface{ctrl: ctrl}
	mock.recorder = &MockUsersServiceInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUsersServiceInterface) EXPECT() *MockUsersServiceInterfaceMockRecorder {
	return m.recorder
}

// ActivateUser mocks base method.
func (m *MockUsersServiceInterface) ActivateUser(user int, options ...gitlab.RequestOptionFunc) error {
	m.ctrl.T.Helper()
	varargs := []any{user}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ActivateUser", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ActivateUser indicates an expected call of ActivateUser.
func (mr *MockUsersServiceInterfaceMockRecorder) ActivateUser(user any, options ...any) *MockUsersServiceInterfaceActivateUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ActivateUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).ActivateUser), varargs...)
	return &MockUsersServiceInterfaceActivateUserCall{Call: call}
}

// MockUsersServiceInterfaceActivateUserCall wrap *gomock.Call
type MockUsersServiceInterfaceActivateUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceActivateUserCall) Return(arg0 error) *MockUsersServiceInterfaceActivateUserCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceActivateUserCall) Do(f func(int, ...gitlab.RequestOptionFunc) error) *MockUsersServiceInterfaceActivateUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceActivateUserCall) DoAndReturn(f func(int, ...gitlab.RequestOptionFunc) error) *MockUsersServiceInterfaceActivateUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddEmail mocks base method.
func (m *MockUsersServiceInterface) AddEmail(opt *gitlab.AddEmailOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Email, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddEmail", varargs...)
	ret0, _ := ret[0].(*gitlab.Email)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// AddEmail indicates an expected call of AddEmail.
func (mr *MockUsersServiceInterfaceMockRecorder) AddEmail(opt any, options ...any) *MockUsersServiceInterfaceAddEmailCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddEmail", reflect.TypeOf((*MockUsersServiceInterface)(nil).AddEmail), varargs...)
	return &MockUsersServiceInterfaceAddEmailCall{Call: call}
}

// MockUsersServiceInterfaceAddEmailCall wrap *gomock.Call
type MockUsersServiceInterfaceAddEmailCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceAddEmailCall) Return(arg0 *gitlab.Email, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceAddEmailCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceAddEmailCall) Do(f func(*gitlab.AddEmailOptions, ...gitlab.RequestOptionFunc) (*gitlab.Email, *gitlab.Response, error)) *MockUsersServiceInterfaceAddEmailCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceAddEmailCall) DoAndReturn(f func(*gitlab.AddEmailOptions, ...gitlab.RequestOptionFunc) (*gitlab.Email, *gitlab.Response, error)) *MockUsersServiceInterfaceAddEmailCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddEmailForUser mocks base method.
func (m *MockUsersServiceInterface) AddEmailForUser(user int, opt *gitlab.AddEmailOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Email, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddEmailForUser", varargs...)
	ret0, _ := ret[0].(*gitlab.Email)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// AddEmailForUser indicates an expected call of AddEmailForUser.
func (mr *MockUsersServiceInterfaceMockRecorder) AddEmailForUser(user, opt any, options ...any) *MockUsersServiceInterfaceAddEmailForUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddEmailForUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).AddEmailForUser), varargs...)
	return &MockUsersServiceInterfaceAddEmailForUserCall{Call: call}
}

// MockUsersServiceInterfaceAddEmailForUserCall wrap *gomock.Call
type MockUsersServiceInterfaceAddEmailForUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceAddEmailForUserCall) Return(arg0 *gitlab.Email, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceAddEmailForUserCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceAddEmailForUserCall) Do(f func(int, *gitlab.AddEmailOptions, ...gitlab.RequestOptionFunc) (*gitlab.Email, *gitlab.Response, error)) *MockUsersServiceInterfaceAddEmailForUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceAddEmailForUserCall) DoAndReturn(f func(int, *gitlab.AddEmailOptions, ...gitlab.RequestOptionFunc) (*gitlab.Email, *gitlab.Response, error)) *MockUsersServiceInterfaceAddEmailForUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddGPGKey mocks base method.
func (m *MockUsersServiceInterface) AddGPGKey(opt *gitlab.AddGPGKeyOptions, options ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddGPGKey", varargs...)
	ret0, _ := ret[0].(*gitlab.GPGKey)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// AddGPGKey indicates an expected call of AddGPGKey.
func (mr *MockUsersServiceInterfaceMockRecorder) AddGPGKey(opt any, options ...any) *MockUsersServiceInterfaceAddGPGKeyCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddGPGKey", reflect.TypeOf((*MockUsersServiceInterface)(nil).AddGPGKey), varargs...)
	return &MockUsersServiceInterfaceAddGPGKeyCall{Call: call}
}

// MockUsersServiceInterfaceAddGPGKeyCall wrap *gomock.Call
type MockUsersServiceInterfaceAddGPGKeyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceAddGPGKeyCall) Return(arg0 *gitlab.GPGKey, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceAddGPGKeyCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceAddGPGKeyCall) Do(f func(*gitlab.AddGPGKeyOptions, ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error)) *MockUsersServiceInterfaceAddGPGKeyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceAddGPGKeyCall) DoAndReturn(f func(*gitlab.AddGPGKeyOptions, ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error)) *MockUsersServiceInterfaceAddGPGKeyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddGPGKeyForUser mocks base method.
func (m *MockUsersServiceInterface) AddGPGKeyForUser(user int, opt *gitlab.AddGPGKeyOptions, options ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddGPGKeyForUser", varargs...)
	ret0, _ := ret[0].(*gitlab.GPGKey)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// AddGPGKeyForUser indicates an expected call of AddGPGKeyForUser.
func (mr *MockUsersServiceInterfaceMockRecorder) AddGPGKeyForUser(user, opt any, options ...any) *MockUsersServiceInterfaceAddGPGKeyForUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddGPGKeyForUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).AddGPGKeyForUser), varargs...)
	return &MockUsersServiceInterfaceAddGPGKeyForUserCall{Call: call}
}

// MockUsersServiceInterfaceAddGPGKeyForUserCall wrap *gomock.Call
type MockUsersServiceInterfaceAddGPGKeyForUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceAddGPGKeyForUserCall) Return(arg0 *gitlab.GPGKey, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceAddGPGKeyForUserCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceAddGPGKeyForUserCall) Do(f func(int, *gitlab.AddGPGKeyOptions, ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error)) *MockUsersServiceInterfaceAddGPGKeyForUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceAddGPGKeyForUserCall) DoAndReturn(f func(int, *gitlab.AddGPGKeyOptions, ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error)) *MockUsersServiceInterfaceAddGPGKeyForUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddSSHKey mocks base method.
func (m *MockUsersServiceInterface) AddSSHKey(opt *gitlab.AddSSHKeyOptions, options ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddSSHKey", varargs...)
	ret0, _ := ret[0].(*gitlab.SSHKey)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// AddSSHKey indicates an expected call of AddSSHKey.
func (mr *MockUsersServiceInterfaceMockRecorder) AddSSHKey(opt any, options ...any) *MockUsersServiceInterfaceAddSSHKeyCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddSSHKey", reflect.TypeOf((*MockUsersServiceInterface)(nil).AddSSHKey), varargs...)
	return &MockUsersServiceInterfaceAddSSHKeyCall{Call: call}
}

// MockUsersServiceInterfaceAddSSHKeyCall wrap *gomock.Call
type MockUsersServiceInterfaceAddSSHKeyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceAddSSHKeyCall) Return(arg0 *gitlab.SSHKey, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceAddSSHKeyCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceAddSSHKeyCall) Do(f func(*gitlab.AddSSHKeyOptions, ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error)) *MockUsersServiceInterfaceAddSSHKeyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceAddSSHKeyCall) DoAndReturn(f func(*gitlab.AddSSHKeyOptions, ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error)) *MockUsersServiceInterfaceAddSSHKeyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddSSHKeyForUser mocks base method.
func (m *MockUsersServiceInterface) AddSSHKeyForUser(user int, opt *gitlab.AddSSHKeyOptions, options ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddSSHKeyForUser", varargs...)
	ret0, _ := ret[0].(*gitlab.SSHKey)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// AddSSHKeyForUser indicates an expected call of AddSSHKeyForUser.
func (mr *MockUsersServiceInterfaceMockRecorder) AddSSHKeyForUser(user, opt any, options ...any) *MockUsersServiceInterfaceAddSSHKeyForUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddSSHKeyForUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).AddSSHKeyForUser), varargs...)
	return &MockUsersServiceInterfaceAddSSHKeyForUserCall{Call: call}
}

// MockUsersServiceInterfaceAddSSHKeyForUserCall wrap *gomock.Call
type MockUsersServiceInterfaceAddSSHKeyForUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceAddSSHKeyForUserCall) Return(arg0 *gitlab.SSHKey, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceAddSSHKeyForUserCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceAddSSHKeyForUserCall) Do(f func(int, *gitlab.AddSSHKeyOptions, ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error)) *MockUsersServiceInterfaceAddSSHKeyForUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceAddSSHKeyForUserCall) DoAndReturn(f func(int, *gitlab.AddSSHKeyOptions, ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error)) *MockUsersServiceInterfaceAddSSHKeyForUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ApproveUser mocks base method.
func (m *MockUsersServiceInterface) ApproveUser(user int, options ...gitlab.RequestOptionFunc) error {
	m.ctrl.T.Helper()
	varargs := []any{user}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ApproveUser", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ApproveUser indicates an expected call of ApproveUser.
func (mr *MockUsersServiceInterfaceMockRecorder) ApproveUser(user any, options ...any) *MockUsersServiceInterfaceApproveUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApproveUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).ApproveUser), varargs...)
	return &MockUsersServiceInterfaceApproveUserCall{Call: call}
}

// MockUsersServiceInterfaceApproveUserCall wrap *gomock.Call
type MockUsersServiceInterfaceApproveUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceApproveUserCall) Return(arg0 error) *MockUsersServiceInterfaceApproveUserCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceApproveUserCall) Do(f func(int, ...gitlab.RequestOptionFunc) error) *MockUsersServiceInterfaceApproveUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceApproveUserCall) DoAndReturn(f func(int, ...gitlab.RequestOptionFunc) error) *MockUsersServiceInterfaceApproveUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BanUser mocks base method.
func (m *MockUsersServiceInterface) BanUser(user int, options ...gitlab.RequestOptionFunc) error {
	m.ctrl.T.Helper()
	varargs := []any{user}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BanUser", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// BanUser indicates an expected call of BanUser.
func (mr *MockUsersServiceInterfaceMockRecorder) BanUser(user any, options ...any) *MockUsersServiceInterfaceBanUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BanUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).BanUser), varargs...)
	return &MockUsersServiceInterfaceBanUserCall{Call: call}
}

// MockUsersServiceInterfaceBanUserCall wrap *gomock.Call
type MockUsersServiceInterfaceBanUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceBanUserCall) Return(arg0 error) *MockUsersServiceInterfaceBanUserCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceBanUserCall) Do(f func(int, ...gitlab.RequestOptionFunc) error) *MockUsersServiceInterfaceBanUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceBanUserCall) DoAndReturn(f func(int, ...gitlab.RequestOptionFunc) error) *MockUsersServiceInterfaceBanUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BlockUser mocks base method.
func (m *MockUsersServiceInterface) BlockUser(user int, options ...gitlab.RequestOptionFunc) error {
	m.ctrl.T.Helper()
	varargs := []any{user}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BlockUser", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// BlockUser indicates an expected call of BlockUser.
func (mr *MockUsersServiceInterfaceMockRecorder) BlockUser(user any, options ...any) *MockUsersServiceInterfaceBlockUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BlockUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).BlockUser), varargs...)
	return &MockUsersServiceInterfaceBlockUserCall{Call: call}
}

// MockUsersServiceInterfaceBlockUserCall wrap *gomock.Call
type MockUsersServiceInterfaceBlockUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceBlockUserCall) Return(arg0 error) *MockUsersServiceInterfaceBlockUserCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceBlockUserCall) Do(f func(int, ...gitlab.RequestOptionFunc) error) *MockUsersServiceInterfaceBlockUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceBlockUserCall) DoAndReturn(f func(int, ...gitlab.RequestOptionFunc) error) *MockUsersServiceInterfaceBlockUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateImpersonationToken mocks base method.
func (m *MockUsersServiceInterface) CreateImpersonationToken(user int, opt *gitlab.CreateImpersonationTokenOptions, options ...gitlab.RequestOptionFunc) (*gitlab.ImpersonationToken, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateImpersonationToken", varargs...)
	ret0, _ := ret[0].(*gitlab.ImpersonationToken)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreateImpersonationToken indicates an expected call of CreateImpersonationToken.
func (mr *MockUsersServiceInterfaceMockRecorder) CreateImpersonationToken(user, opt any, options ...any) *MockUsersServiceInterfaceCreateImpersonationTokenCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateImpersonationToken", reflect.TypeOf((*MockUsersServiceInterface)(nil).CreateImpersonationToken), varargs...)
	return &MockUsersServiceInterfaceCreateImpersonationTokenCall{Call: call}
}

// MockUsersServiceInterfaceCreateImpersonationTokenCall wrap *gomock.Call
type MockUsersServiceInterfaceCreateImpersonationTokenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceCreateImpersonationTokenCall) Return(arg0 *gitlab.ImpersonationToken, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceCreateImpersonationTokenCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceCreateImpersonationTokenCall) Do(f func(int, *gitlab.CreateImpersonationTokenOptions, ...gitlab.RequestOptionFunc) (*gitlab.ImpersonationToken, *gitlab.Response, error)) *MockUsersServiceInterfaceCreateImpersonationTokenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceCreateImpersonationTokenCall) DoAndReturn(f func(int, *gitlab.CreateImpersonationTokenOptions, ...gitlab.RequestOptionFunc) (*gitlab.ImpersonationToken, *gitlab.Response, error)) *MockUsersServiceInterfaceCreateImpersonationTokenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreatePersonalAccessToken mocks base method.
func (m *MockUsersServiceInterface) CreatePersonalAccessToken(user int, opt *gitlab.CreatePersonalAccessTokenOptions, options ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreatePersonalAccessToken", varargs...)
	ret0, _ := ret[0].(*gitlab.PersonalAccessToken)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreatePersonalAccessToken indicates an expected call of CreatePersonalAccessToken.
func (mr *MockUsersServiceInterfaceMockRecorder) CreatePersonalAccessToken(user, opt any, options ...any) *MockUsersServiceInterfaceCreatePersonalAccessTokenCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreatePersonalAccessToken", reflect.TypeOf((*MockUsersServiceInterface)(nil).CreatePersonalAccessToken), varargs...)
	return &MockUsersServiceInterfaceCreatePersonalAccessTokenCall{Call: call}
}

// MockUsersServiceInterfaceCreatePersonalAccessTokenCall wrap *gomock.Call
type MockUsersServiceInterfaceCreatePersonalAccessTokenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceCreatePersonalAccessTokenCall) Return(arg0 *gitlab.PersonalAccessToken, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceCreatePersonalAccessTokenCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceCreatePersonalAccessTokenCall) Do(f func(int, *gitlab.CreatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)) *MockUsersServiceInterfaceCreatePersonalAccessTokenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceCreatePersonalAccessTokenCall) DoAndReturn(f func(int, *gitlab.CreatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)) *MockUsersServiceInterfaceCreatePersonalAccessTokenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreatePersonalAccessTokenForCurrentUser mocks base method.
func (m *MockUsersServiceInterface) CreatePersonalAccessTokenForCurrentUser(opt *gitlab.CreatePersonalAccessTokenForCurrentUserOptions, options ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreatePersonalAccessTokenForCurrentUser", varargs...)
	ret0, _ := ret[0].(*gitlab.PersonalAccessToken)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreatePersonalAccessTokenForCurrentUser indicates an expected call of CreatePersonalAccessTokenForCurrentUser.
func (mr *MockUsersServiceInterfaceMockRecorder) CreatePersonalAccessTokenForCurrentUser(opt any, options ...any) *MockUsersServiceInterfaceCreatePersonalAccessTokenForCurrentUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreatePersonalAccessTokenForCurrentUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).CreatePersonalAccessTokenForCurrentUser), varargs...)
	return &MockUsersServiceInterfaceCreatePersonalAccessTokenForCurrentUserCall{Call: call}
}

// MockUsersServiceInterfaceCreatePersonalAccessTokenForCurrentUserCall wrap *gomock.Call
type MockUsersServiceInterfaceCreatePersonalAccessTokenForCurrentUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceCreatePersonalAccessTokenForCurrentUserCall) Return(arg0 *gitlab.PersonalAccessToken, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceCreatePersonalAccessTokenForCurrentUserCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceCreatePersonalAccessTokenForCurrentUserCall) Do(f func(*gitlab.CreatePersonalAccessTokenForCurrentUserOptions, ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)) *MockUsersServiceInterfaceCreatePersonalAccessTokenForCurrentUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceCreatePersonalAccessTokenForCurrentUserCall) DoAndReturn(f func(*gitlab.CreatePersonalAccessTokenForCurrentUserOptions, ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)) *MockUsersServiceInterfaceCreatePersonalAccessTokenForCurrentUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateServiceAccountUser mocks base method.
func (m *MockUsersServiceInterface) CreateServiceAccountUser(opts *gitlab.CreateServiceAccountUserOptions, options ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{opts}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateServiceAccountUser", varargs...)
	ret0, _ := ret[0].(*gitlab.User)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreateServiceAccountUser indicates an expected call of CreateServiceAccountUser.
func (mr *MockUsersServiceInterfaceMockRecorder) CreateServiceAccountUser(opts any, options ...any) *MockUsersServiceInterfaceCreateServiceAccountUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{opts}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateServiceAccountUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).CreateServiceAccountUser), varargs...)
	return &MockUsersServiceInterfaceCreateServiceAccountUserCall{Call: call}
}

// MockUsersServiceInterfaceCreateServiceAccountUserCall wrap *gomock.Call
type MockUsersServiceInterfaceCreateServiceAccountUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceCreateServiceAccountUserCall) Return(arg0 *gitlab.User, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceCreateServiceAccountUserCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceCreateServiceAccountUserCall) Do(f func(*gitlab.CreateServiceAccountUserOptions, ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)) *MockUsersServiceInterfaceCreateServiceAccountUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceCreateServiceAccountUserCall) DoAndReturn(f func(*gitlab.CreateServiceAccountUserOptions, ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)) *MockUsersServiceInterfaceCreateServiceAccountUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateUser mocks base method.
func (m *MockUsersServiceInterface) CreateUser(opt *gitlab.CreateUserOptions, options ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateUser", varargs...)
	ret0, _ := ret[0].(*gitlab.User)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreateUser indicates an expected call of CreateUser.
func (mr *MockUsersServiceInterfaceMockRecorder) CreateUser(opt any, options ...any) *MockUsersServiceInterfaceCreateUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).CreateUser), varargs...)
	return &MockUsersServiceInterfaceCreateUserCall{Call: call}
}

// MockUsersServiceInterfaceCreateUserCall wrap *gomock.Call
type MockUsersServiceInterfaceCreateUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceCreateUserCall) Return(arg0 *gitlab.User, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceCreateUserCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceCreateUserCall) Do(f func(*gitlab.CreateUserOptions, ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)) *MockUsersServiceInterfaceCreateUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceCreateUserCall) DoAndReturn(f func(*gitlab.CreateUserOptions, ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)) *MockUsersServiceInterfaceCreateUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateUserRunner mocks base method.
func (m *MockUsersServiceInterface) CreateUserRunner(opts *gitlab.CreateUserRunnerOptions, options ...gitlab.RequestOptionFunc) (*gitlab.UserRunner, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{opts}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateUserRunner", varargs...)
	ret0, _ := ret[0].(*gitlab.UserRunner)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreateUserRunner indicates an expected call of CreateUserRunner.
func (mr *MockUsersServiceInterfaceMockRecorder) CreateUserRunner(opts any, options ...any) *MockUsersServiceInterfaceCreateUserRunnerCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{opts}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUserRunner", reflect.TypeOf((*MockUsersServiceInterface)(nil).CreateUserRunner), varargs...)
	return &MockUsersServiceInterfaceCreateUserRunnerCall{Call: call}
}

// MockUsersServiceInterfaceCreateUserRunnerCall wrap *gomock.Call
type MockUsersServiceInterfaceCreateUserRunnerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceCreateUserRunnerCall) Return(arg0 *gitlab.UserRunner, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceCreateUserRunnerCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceCreateUserRunnerCall) Do(f func(*gitlab.CreateUserRunnerOptions, ...gitlab.RequestOptionFunc) (*gitlab.UserRunner, *gitlab.Response, error)) *MockUsersServiceInterfaceCreateUserRunnerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceCreateUserRunnerCall) DoAndReturn(f func(*gitlab.CreateUserRunnerOptions, ...gitlab.RequestOptionFunc) (*gitlab.UserRunner, *gitlab.Response, error)) *MockUsersServiceInterfaceCreateUserRunnerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CurrentUser mocks base method.
func (m *MockUsersServiceInterface) CurrentUser(options ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CurrentUser", varargs...)
	ret0, _ := ret[0].(*gitlab.User)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CurrentUser indicates an expected call of CurrentUser.
func (mr *MockUsersServiceInterfaceMockRecorder) CurrentUser(options ...any) *MockUsersServiceInterfaceCurrentUserCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CurrentUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).CurrentUser), options...)
	return &MockUsersServiceInterfaceCurrentUserCall{Call: call}
}

// MockUsersServiceInterfaceCurrentUserCall wrap *gomock.Call
type MockUsersServiceInterfaceCurrentUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceCurrentUserCall) Return(arg0 *gitlab.User, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceCurrentUserCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceCurrentUserCall) Do(f func(...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)) *MockUsersServiceInterfaceCurrentUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceCurrentUserCall) DoAndReturn(f func(...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)) *MockUsersServiceInterfaceCurrentUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CurrentUserStatus mocks base method.
func (m *MockUsersServiceInterface) CurrentUserStatus(options ...gitlab.RequestOptionFunc) (*gitlab.UserStatus, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CurrentUserStatus", varargs...)
	ret0, _ := ret[0].(*gitlab.UserStatus)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CurrentUserStatus indicates an expected call of CurrentUserStatus.
func (mr *MockUsersServiceInterfaceMockRecorder) CurrentUserStatus(options ...any) *MockUsersServiceInterfaceCurrentUserStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CurrentUserStatus", reflect.TypeOf((*MockUsersServiceInterface)(nil).CurrentUserStatus), options...)
	return &MockUsersServiceInterfaceCurrentUserStatusCall{Call: call}
}

// MockUsersServiceInterfaceCurrentUserStatusCall wrap *gomock.Call
type MockUsersServiceInterfaceCurrentUserStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceCurrentUserStatusCall) Return(arg0 *gitlab.UserStatus, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceCurrentUserStatusCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceCurrentUserStatusCall) Do(f func(...gitlab.RequestOptionFunc) (*gitlab.UserStatus, *gitlab.Response, error)) *MockUsersServiceInterfaceCurrentUserStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceCurrentUserStatusCall) DoAndReturn(f func(...gitlab.RequestOptionFunc) (*gitlab.UserStatus, *gitlab.Response, error)) *MockUsersServiceInterfaceCurrentUserStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeactivateUser mocks base method.
func (m *MockUsersServiceInterface) DeactivateUser(user int, options ...gitlab.RequestOptionFunc) error {
	m.ctrl.T.Helper()
	varargs := []any{user}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeactivateUser", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeactivateUser indicates an expected call of DeactivateUser.
func (mr *MockUsersServiceInterfaceMockRecorder) DeactivateUser(user any, options ...any) *MockUsersServiceInterfaceDeactivateUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeactivateUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).DeactivateUser), varargs...)
	return &MockUsersServiceInterfaceDeactivateUserCall{Call: call}
}

// MockUsersServiceInterfaceDeactivateUserCall wrap *gomock.Call
type MockUsersServiceInterfaceDeactivateUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceDeactivateUserCall) Return(arg0 error) *MockUsersServiceInterfaceDeactivateUserCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceDeactivateUserCall) Do(f func(int, ...gitlab.RequestOptionFunc) error) *MockUsersServiceInterfaceDeactivateUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceDeactivateUserCall) DoAndReturn(f func(int, ...gitlab.RequestOptionFunc) error) *MockUsersServiceInterfaceDeactivateUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteEmail mocks base method.
func (m *MockUsersServiceInterface) DeleteEmail(email int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{email}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteEmail", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteEmail indicates an expected call of DeleteEmail.
func (mr *MockUsersServiceInterfaceMockRecorder) DeleteEmail(email any, options ...any) *MockUsersServiceInterfaceDeleteEmailCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{email}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteEmail", reflect.TypeOf((*MockUsersServiceInterface)(nil).DeleteEmail), varargs...)
	return &MockUsersServiceInterfaceDeleteEmailCall{Call: call}
}

// MockUsersServiceInterfaceDeleteEmailCall wrap *gomock.Call
type MockUsersServiceInterfaceDeleteEmailCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceDeleteEmailCall) Return(arg0 *gitlab.Response, arg1 error) *MockUsersServiceInterfaceDeleteEmailCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceDeleteEmailCall) Do(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockUsersServiceInterfaceDeleteEmailCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceDeleteEmailCall) DoAndReturn(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockUsersServiceInterfaceDeleteEmailCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteEmailForUser mocks base method.
func (m *MockUsersServiceInterface) DeleteEmailForUser(user, email int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user, email}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteEmailForUser", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteEmailForUser indicates an expected call of DeleteEmailForUser.
func (mr *MockUsersServiceInterfaceMockRecorder) DeleteEmailForUser(user, email any, options ...any) *MockUsersServiceInterfaceDeleteEmailForUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user, email}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteEmailForUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).DeleteEmailForUser), varargs...)
	return &MockUsersServiceInterfaceDeleteEmailForUserCall{Call: call}
}

// MockUsersServiceInterfaceDeleteEmailForUserCall wrap *gomock.Call
type MockUsersServiceInterfaceDeleteEmailForUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceDeleteEmailForUserCall) Return(arg0 *gitlab.Response, arg1 error) *MockUsersServiceInterfaceDeleteEmailForUserCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceDeleteEmailForUserCall) Do(f func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockUsersServiceInterfaceDeleteEmailForUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceDeleteEmailForUserCall) DoAndReturn(f func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockUsersServiceInterfaceDeleteEmailForUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteGPGKey mocks base method.
func (m *MockUsersServiceInterface) DeleteGPGKey(key int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{key}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteGPGKey", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteGPGKey indicates an expected call of DeleteGPGKey.
func (mr *MockUsersServiceInterfaceMockRecorder) DeleteGPGKey(key any, options ...any) *MockUsersServiceInterfaceDeleteGPGKeyCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{key}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteGPGKey", reflect.TypeOf((*MockUsersServiceInterface)(nil).DeleteGPGKey), varargs...)
	return &MockUsersServiceInterfaceDeleteGPGKeyCall{Call: call}
}

// MockUsersServiceInterfaceDeleteGPGKeyCall wrap *gomock.Call
type MockUsersServiceInterfaceDeleteGPGKeyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceDeleteGPGKeyCall) Return(arg0 *gitlab.Response, arg1 error) *MockUsersServiceInterfaceDeleteGPGKeyCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceDeleteGPGKeyCall) Do(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockUsersServiceInterfaceDeleteGPGKeyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceDeleteGPGKeyCall) DoAndReturn(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockUsersServiceInterfaceDeleteGPGKeyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteGPGKeyForUser mocks base method.
func (m *MockUsersServiceInterface) DeleteGPGKeyForUser(user, key int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user, key}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteGPGKeyForUser", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteGPGKeyForUser indicates an expected call of DeleteGPGKeyForUser.
func (mr *MockUsersServiceInterfaceMockRecorder) DeleteGPGKeyForUser(user, key any, options ...any) *MockUsersServiceInterfaceDeleteGPGKeyForUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user, key}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteGPGKeyForUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).DeleteGPGKeyForUser), varargs...)
	return &MockUsersServiceInterfaceDeleteGPGKeyForUserCall{Call: call}
}

// MockUsersServiceInterfaceDeleteGPGKeyForUserCall wrap *gomock.Call
type MockUsersServiceInterfaceDeleteGPGKeyForUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceDeleteGPGKeyForUserCall) Return(arg0 *gitlab.Response, arg1 error) *MockUsersServiceInterfaceDeleteGPGKeyForUserCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceDeleteGPGKeyForUserCall) Do(f func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockUsersServiceInterfaceDeleteGPGKeyForUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceDeleteGPGKeyForUserCall) DoAndReturn(f func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockUsersServiceInterfaceDeleteGPGKeyForUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteSSHKey mocks base method.
func (m *MockUsersServiceInterface) DeleteSSHKey(key int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{key}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteSSHKey", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteSSHKey indicates an expected call of DeleteSSHKey.
func (mr *MockUsersServiceInterfaceMockRecorder) DeleteSSHKey(key any, options ...any) *MockUsersServiceInterfaceDeleteSSHKeyCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{key}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSSHKey", reflect.TypeOf((*MockUsersServiceInterface)(nil).DeleteSSHKey), varargs...)
	return &MockUsersServiceInterfaceDeleteSSHKeyCall{Call: call}
}

// MockUsersServiceInterfaceDeleteSSHKeyCall wrap *gomock.Call
type MockUsersServiceInterfaceDeleteSSHKeyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceDeleteSSHKeyCall) Return(arg0 *gitlab.Response, arg1 error) *MockUsersServiceInterfaceDeleteSSHKeyCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceDeleteSSHKeyCall) Do(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockUsersServiceInterfaceDeleteSSHKeyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceDeleteSSHKeyCall) DoAndReturn(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockUsersServiceInterfaceDeleteSSHKeyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteSSHKeyForUser mocks base method.
func (m *MockUsersServiceInterface) DeleteSSHKeyForUser(user, key int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user, key}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteSSHKeyForUser", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteSSHKeyForUser indicates an expected call of DeleteSSHKeyForUser.
func (mr *MockUsersServiceInterfaceMockRecorder) DeleteSSHKeyForUser(user, key any, options ...any) *MockUsersServiceInterfaceDeleteSSHKeyForUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user, key}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSSHKeyForUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).DeleteSSHKeyForUser), varargs...)
	return &MockUsersServiceInterfaceDeleteSSHKeyForUserCall{Call: call}
}

// MockUsersServiceInterfaceDeleteSSHKeyForUserCall wrap *gomock.Call
type MockUsersServiceInterfaceDeleteSSHKeyForUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceDeleteSSHKeyForUserCall) Return(arg0 *gitlab.Response, arg1 error) *MockUsersServiceInterfaceDeleteSSHKeyForUserCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceDeleteSSHKeyForUserCall) Do(f func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockUsersServiceInterfaceDeleteSSHKeyForUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceDeleteSSHKeyForUserCall) DoAndReturn(f func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockUsersServiceInterfaceDeleteSSHKeyForUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteUser mocks base method.
func (m *MockUsersServiceInterface) DeleteUser(user int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteUser", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteUser indicates an expected call of DeleteUser.
func (mr *MockUsersServiceInterfaceMockRecorder) DeleteUser(user any, options ...any) *MockUsersServiceInterfaceDeleteUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).DeleteUser), varargs...)
	return &MockUsersServiceInterfaceDeleteUserCall{Call: call}
}

// MockUsersServiceInterfaceDeleteUserCall wrap *gomock.Call
type MockUsersServiceInterfaceDeleteUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceDeleteUserCall) Return(arg0 *gitlab.Response, arg1 error) *MockUsersServiceInterfaceDeleteUserCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceDeleteUserCall) Do(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockUsersServiceInterfaceDeleteUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceDeleteUserCall) DoAndReturn(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockUsersServiceInterfaceDeleteUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteUserIdentity mocks base method.
func (m *MockUsersServiceInterface) DeleteUserIdentity(user int, provider string, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user, provider}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteUserIdentity", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteUserIdentity indicates an expected call of DeleteUserIdentity.
func (mr *MockUsersServiceInterfaceMockRecorder) DeleteUserIdentity(user, provider any, options ...any) *MockUsersServiceInterfaceDeleteUserIdentityCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user, provider}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteUserIdentity", reflect.TypeOf((*MockUsersServiceInterface)(nil).DeleteUserIdentity), varargs...)
	return &MockUsersServiceInterfaceDeleteUserIdentityCall{Call: call}
}

// MockUsersServiceInterfaceDeleteUserIdentityCall wrap *gomock.Call
type MockUsersServiceInterfaceDeleteUserIdentityCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceDeleteUserIdentityCall) Return(arg0 *gitlab.Response, arg1 error) *MockUsersServiceInterfaceDeleteUserIdentityCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceDeleteUserIdentityCall) Do(f func(int, string, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockUsersServiceInterfaceDeleteUserIdentityCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceDeleteUserIdentityCall) DoAndReturn(f func(int, string, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockUsersServiceInterfaceDeleteUserIdentityCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DisableTwoFactor mocks base method.
func (m *MockUsersServiceInterface) DisableTwoFactor(user int, options ...gitlab.RequestOptionFunc) error {
	m.ctrl.T.Helper()
	varargs := []any{user}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DisableTwoFactor", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DisableTwoFactor indicates an expected call of DisableTwoFactor.
func (mr *MockUsersServiceInterfaceMockRecorder) DisableTwoFactor(user any, options ...any) *MockUsersServiceInterfaceDisableTwoFactorCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DisableTwoFactor", reflect.TypeOf((*MockUsersServiceInterface)(nil).DisableTwoFactor), varargs...)
	return &MockUsersServiceInterfaceDisableTwoFactorCall{Call: call}
}

// MockUsersServiceInterfaceDisableTwoFactorCall wrap *gomock.Call
type MockUsersServiceInterfaceDisableTwoFactorCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceDisableTwoFactorCall) Return(arg0 error) *MockUsersServiceInterfaceDisableTwoFactorCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceDisableTwoFactorCall) Do(f func(int, ...gitlab.RequestOptionFunc) error) *MockUsersServiceInterfaceDisableTwoFactorCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceDisableTwoFactorCall) DoAndReturn(f func(int, ...gitlab.RequestOptionFunc) error) *MockUsersServiceInterfaceDisableTwoFactorCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAllImpersonationTokens mocks base method.
func (m *MockUsersServiceInterface) GetAllImpersonationTokens(user int, opt *gitlab.GetAllImpersonationTokensOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.ImpersonationToken, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetAllImpersonationTokens", varargs...)
	ret0, _ := ret[0].([]*gitlab.ImpersonationToken)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetAllImpersonationTokens indicates an expected call of GetAllImpersonationTokens.
func (mr *MockUsersServiceInterfaceMockRecorder) GetAllImpersonationTokens(user, opt any, options ...any) *MockUsersServiceInterfaceGetAllImpersonationTokensCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllImpersonationTokens", reflect.TypeOf((*MockUsersServiceInterface)(nil).GetAllImpersonationTokens), varargs...)
	return &MockUsersServiceInterfaceGetAllImpersonationTokensCall{Call: call}
}

// MockUsersServiceInterfaceGetAllImpersonationTokensCall wrap *gomock.Call
type MockUsersServiceInterfaceGetAllImpersonationTokensCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceGetAllImpersonationTokensCall) Return(arg0 []*gitlab.ImpersonationToken, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceGetAllImpersonationTokensCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceGetAllImpersonationTokensCall) Do(f func(int, *gitlab.GetAllImpersonationTokensOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ImpersonationToken, *gitlab.Response, error)) *MockUsersServiceInterfaceGetAllImpersonationTokensCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceGetAllImpersonationTokensCall) DoAndReturn(f func(int, *gitlab.GetAllImpersonationTokensOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ImpersonationToken, *gitlab.Response, error)) *MockUsersServiceInterfaceGetAllImpersonationTokensCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetEmail mocks base method.
func (m *MockUsersServiceInterface) GetEmail(email int, options ...gitlab.RequestOptionFunc) (*gitlab.Email, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{email}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetEmail", varargs...)
	ret0, _ := ret[0].(*gitlab.Email)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetEmail indicates an expected call of GetEmail.
func (mr *MockUsersServiceInterfaceMockRecorder) GetEmail(email any, options ...any) *MockUsersServiceInterfaceGetEmailCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{email}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEmail", reflect.TypeOf((*MockUsersServiceInterface)(nil).GetEmail), varargs...)
	return &MockUsersServiceInterfaceGetEmailCall{Call: call}
}

// MockUsersServiceInterfaceGetEmailCall wrap *gomock.Call
type MockUsersServiceInterfaceGetEmailCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceGetEmailCall) Return(arg0 *gitlab.Email, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceGetEmailCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceGetEmailCall) Do(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.Email, *gitlab.Response, error)) *MockUsersServiceInterfaceGetEmailCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceGetEmailCall) DoAndReturn(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.Email, *gitlab.Response, error)) *MockUsersServiceInterfaceGetEmailCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetGPGKey mocks base method.
func (m *MockUsersServiceInterface) GetGPGKey(key int, options ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{key}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetGPGKey", varargs...)
	ret0, _ := ret[0].(*gitlab.GPGKey)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetGPGKey indicates an expected call of GetGPGKey.
func (mr *MockUsersServiceInterfaceMockRecorder) GetGPGKey(key any, options ...any) *MockUsersServiceInterfaceGetGPGKeyCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{key}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetGPGKey", reflect.TypeOf((*MockUsersServiceInterface)(nil).GetGPGKey), varargs...)
	return &MockUsersServiceInterfaceGetGPGKeyCall{Call: call}
}

// MockUsersServiceInterfaceGetGPGKeyCall wrap *gomock.Call
type MockUsersServiceInterfaceGetGPGKeyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceGetGPGKeyCall) Return(arg0 *gitlab.GPGKey, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceGetGPGKeyCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceGetGPGKeyCall) Do(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error)) *MockUsersServiceInterfaceGetGPGKeyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceGetGPGKeyCall) DoAndReturn(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error)) *MockUsersServiceInterfaceGetGPGKeyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetGPGKeyForUser mocks base method.
func (m *MockUsersServiceInterface) GetGPGKeyForUser(user, key int, options ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user, key}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetGPGKeyForUser", varargs...)
	ret0, _ := ret[0].(*gitlab.GPGKey)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetGPGKeyForUser indicates an expected call of GetGPGKeyForUser.
func (mr *MockUsersServiceInterfaceMockRecorder) GetGPGKeyForUser(user, key any, options ...any) *MockUsersServiceInterfaceGetGPGKeyForUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user, key}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetGPGKeyForUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).GetGPGKeyForUser), varargs...)
	return &MockUsersServiceInterfaceGetGPGKeyForUserCall{Call: call}
}

// MockUsersServiceInterfaceGetGPGKeyForUserCall wrap *gomock.Call
type MockUsersServiceInterfaceGetGPGKeyForUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceGetGPGKeyForUserCall) Return(arg0 *gitlab.GPGKey, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceGetGPGKeyForUserCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceGetGPGKeyForUserCall) Do(f func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error)) *MockUsersServiceInterfaceGetGPGKeyForUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceGetGPGKeyForUserCall) DoAndReturn(f func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error)) *MockUsersServiceInterfaceGetGPGKeyForUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetImpersonationToken mocks base method.
func (m *MockUsersServiceInterface) GetImpersonationToken(user, token int, options ...gitlab.RequestOptionFunc) (*gitlab.ImpersonationToken, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user, token}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetImpersonationToken", varargs...)
	ret0, _ := ret[0].(*gitlab.ImpersonationToken)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetImpersonationToken indicates an expected call of GetImpersonationToken.
func (mr *MockUsersServiceInterfaceMockRecorder) GetImpersonationToken(user, token any, options ...any) *MockUsersServiceInterfaceGetImpersonationTokenCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user, token}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetImpersonationToken", reflect.TypeOf((*MockUsersServiceInterface)(nil).GetImpersonationToken), varargs...)
	return &MockUsersServiceInterfaceGetImpersonationTokenCall{Call: call}
}

// MockUsersServiceInterfaceGetImpersonationTokenCall wrap *gomock.Call
type MockUsersServiceInterfaceGetImpersonationTokenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceGetImpersonationTokenCall) Return(arg0 *gitlab.ImpersonationToken, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceGetImpersonationTokenCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceGetImpersonationTokenCall) Do(f func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.ImpersonationToken, *gitlab.Response, error)) *MockUsersServiceInterfaceGetImpersonationTokenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceGetImpersonationTokenCall) DoAndReturn(f func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.ImpersonationToken, *gitlab.Response, error)) *MockUsersServiceInterfaceGetImpersonationTokenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetSSHKey mocks base method.
func (m *MockUsersServiceInterface) GetSSHKey(key int, options ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{key}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetSSHKey", varargs...)
	ret0, _ := ret[0].(*gitlab.SSHKey)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetSSHKey indicates an expected call of GetSSHKey.
func (mr *MockUsersServiceInterfaceMockRecorder) GetSSHKey(key any, options ...any) *MockUsersServiceInterfaceGetSSHKeyCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{key}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSSHKey", reflect.TypeOf((*MockUsersServiceInterface)(nil).GetSSHKey), varargs...)
	return &MockUsersServiceInterfaceGetSSHKeyCall{Call: call}
}

// MockUsersServiceInterfaceGetSSHKeyCall wrap *gomock.Call
type MockUsersServiceInterfaceGetSSHKeyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceGetSSHKeyCall) Return(arg0 *gitlab.SSHKey, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceGetSSHKeyCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceGetSSHKeyCall) Do(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error)) *MockUsersServiceInterfaceGetSSHKeyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceGetSSHKeyCall) DoAndReturn(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error)) *MockUsersServiceInterfaceGetSSHKeyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetSSHKeyForUser mocks base method.
func (m *MockUsersServiceInterface) GetSSHKeyForUser(user, key int, options ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user, key}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetSSHKeyForUser", varargs...)
	ret0, _ := ret[0].(*gitlab.SSHKey)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetSSHKeyForUser indicates an expected call of GetSSHKeyForUser.
func (mr *MockUsersServiceInterfaceMockRecorder) GetSSHKeyForUser(user, key any, options ...any) *MockUsersServiceInterfaceGetSSHKeyForUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user, key}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSSHKeyForUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).GetSSHKeyForUser), varargs...)
	return &MockUsersServiceInterfaceGetSSHKeyForUserCall{Call: call}
}

// MockUsersServiceInterfaceGetSSHKeyForUserCall wrap *gomock.Call
type MockUsersServiceInterfaceGetSSHKeyForUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceGetSSHKeyForUserCall) Return(arg0 *gitlab.SSHKey, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceGetSSHKeyForUserCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceGetSSHKeyForUserCall) Do(f func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error)) *MockUsersServiceInterfaceGetSSHKeyForUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceGetSSHKeyForUserCall) DoAndReturn(f func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error)) *MockUsersServiceInterfaceGetSSHKeyForUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUser mocks base method.
func (m *MockUsersServiceInterface) GetUser(user int, opt gitlab.GetUsersOptions, options ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetUser", varargs...)
	ret0, _ := ret[0].(*gitlab.User)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetUser indicates an expected call of GetUser.
func (mr *MockUsersServiceInterfaceMockRecorder) GetUser(user, opt any, options ...any) *MockUsersServiceInterfaceGetUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).GetUser), varargs...)
	return &MockUsersServiceInterfaceGetUserCall{Call: call}
}

// MockUsersServiceInterfaceGetUserCall wrap *gomock.Call
type MockUsersServiceInterfaceGetUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceGetUserCall) Return(arg0 *gitlab.User, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceGetUserCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceGetUserCall) Do(f func(int, gitlab.GetUsersOptions, ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)) *MockUsersServiceInterfaceGetUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceGetUserCall) DoAndReturn(f func(int, gitlab.GetUsersOptions, ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)) *MockUsersServiceInterfaceGetUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUserActivities mocks base method.
func (m *MockUsersServiceInterface) GetUserActivities(opt *gitlab.GetUserActivitiesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.UserActivity, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetUserActivities", varargs...)
	ret0, _ := ret[0].([]*gitlab.UserActivity)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetUserActivities indicates an expected call of GetUserActivities.
func (mr *MockUsersServiceInterfaceMockRecorder) GetUserActivities(opt any, options ...any) *MockUsersServiceInterfaceGetUserActivitiesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserActivities", reflect.TypeOf((*MockUsersServiceInterface)(nil).GetUserActivities), varargs...)
	return &MockUsersServiceInterfaceGetUserActivitiesCall{Call: call}
}

// MockUsersServiceInterfaceGetUserActivitiesCall wrap *gomock.Call
type MockUsersServiceInterfaceGetUserActivitiesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceGetUserActivitiesCall) Return(arg0 []*gitlab.UserActivity, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceGetUserActivitiesCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceGetUserActivitiesCall) Do(f func(*gitlab.GetUserActivitiesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.UserActivity, *gitlab.Response, error)) *MockUsersServiceInterfaceGetUserActivitiesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceGetUserActivitiesCall) DoAndReturn(f func(*gitlab.GetUserActivitiesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.UserActivity, *gitlab.Response, error)) *MockUsersServiceInterfaceGetUserActivitiesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUserAssociationsCount mocks base method.
func (m *MockUsersServiceInterface) GetUserAssociationsCount(user int, options ...gitlab.RequestOptionFunc) (*gitlab.UserAssociationsCount, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetUserAssociationsCount", varargs...)
	ret0, _ := ret[0].(*gitlab.UserAssociationsCount)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetUserAssociationsCount indicates an expected call of GetUserAssociationsCount.
func (mr *MockUsersServiceInterfaceMockRecorder) GetUserAssociationsCount(user any, options ...any) *MockUsersServiceInterfaceGetUserAssociationsCountCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserAssociationsCount", reflect.TypeOf((*MockUsersServiceInterface)(nil).GetUserAssociationsCount), varargs...)
	return &MockUsersServiceInterfaceGetUserAssociationsCountCall{Call: call}
}

// MockUsersServiceInterfaceGetUserAssociationsCountCall wrap *gomock.Call
type MockUsersServiceInterfaceGetUserAssociationsCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceGetUserAssociationsCountCall) Return(arg0 *gitlab.UserAssociationsCount, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceGetUserAssociationsCountCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceGetUserAssociationsCountCall) Do(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.UserAssociationsCount, *gitlab.Response, error)) *MockUsersServiceInterfaceGetUserAssociationsCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceGetUserAssociationsCountCall) DoAndReturn(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.UserAssociationsCount, *gitlab.Response, error)) *MockUsersServiceInterfaceGetUserAssociationsCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUserMemberships mocks base method.
func (m *MockUsersServiceInterface) GetUserMemberships(user int, opt *gitlab.GetUserMembershipOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.UserMembership, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetUserMemberships", varargs...)
	ret0, _ := ret[0].([]*gitlab.UserMembership)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetUserMemberships indicates an expected call of GetUserMemberships.
func (mr *MockUsersServiceInterfaceMockRecorder) GetUserMemberships(user, opt any, options ...any) *MockUsersServiceInterfaceGetUserMembershipsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserMemberships", reflect.TypeOf((*MockUsersServiceInterface)(nil).GetUserMemberships), varargs...)
	return &MockUsersServiceInterfaceGetUserMembershipsCall{Call: call}
}

// MockUsersServiceInterfaceGetUserMembershipsCall wrap *gomock.Call
type MockUsersServiceInterfaceGetUserMembershipsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceGetUserMembershipsCall) Return(arg0 []*gitlab.UserMembership, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceGetUserMembershipsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceGetUserMembershipsCall) Do(f func(int, *gitlab.GetUserMembershipOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.UserMembership, *gitlab.Response, error)) *MockUsersServiceInterfaceGetUserMembershipsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceGetUserMembershipsCall) DoAndReturn(f func(int, *gitlab.GetUserMembershipOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.UserMembership, *gitlab.Response, error)) *MockUsersServiceInterfaceGetUserMembershipsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUserStatus mocks base method.
func (m *MockUsersServiceInterface) GetUserStatus(uid any, options ...gitlab.RequestOptionFunc) (*gitlab.UserStatus, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{uid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetUserStatus", varargs...)
	ret0, _ := ret[0].(*gitlab.UserStatus)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetUserStatus indicates an expected call of GetUserStatus.
func (mr *MockUsersServiceInterfaceMockRecorder) GetUserStatus(uid any, options ...any) *MockUsersServiceInterfaceGetUserStatusCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{uid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserStatus", reflect.TypeOf((*MockUsersServiceInterface)(nil).GetUserStatus), varargs...)
	return &MockUsersServiceInterfaceGetUserStatusCall{Call: call}
}

// MockUsersServiceInterfaceGetUserStatusCall wrap *gomock.Call
type MockUsersServiceInterfaceGetUserStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceGetUserStatusCall) Return(arg0 *gitlab.UserStatus, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceGetUserStatusCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceGetUserStatusCall) Do(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.UserStatus, *gitlab.Response, error)) *MockUsersServiceInterfaceGetUserStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceGetUserStatusCall) DoAndReturn(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.UserStatus, *gitlab.Response, error)) *MockUsersServiceInterfaceGetUserStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListEmails mocks base method.
func (m *MockUsersServiceInterface) ListEmails(options ...gitlab.RequestOptionFunc) ([]*gitlab.Email, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListEmails", varargs...)
	ret0, _ := ret[0].([]*gitlab.Email)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListEmails indicates an expected call of ListEmails.
func (mr *MockUsersServiceInterfaceMockRecorder) ListEmails(options ...any) *MockUsersServiceInterfaceListEmailsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListEmails", reflect.TypeOf((*MockUsersServiceInterface)(nil).ListEmails), options...)
	return &MockUsersServiceInterfaceListEmailsCall{Call: call}
}

// MockUsersServiceInterfaceListEmailsCall wrap *gomock.Call
type MockUsersServiceInterfaceListEmailsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceListEmailsCall) Return(arg0 []*gitlab.Email, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceListEmailsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceListEmailsCall) Do(f func(...gitlab.RequestOptionFunc) ([]*gitlab.Email, *gitlab.Response, error)) *MockUsersServiceInterfaceListEmailsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceListEmailsCall) DoAndReturn(f func(...gitlab.RequestOptionFunc) ([]*gitlab.Email, *gitlab.Response, error)) *MockUsersServiceInterfaceListEmailsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListEmailsForUser mocks base method.
func (m *MockUsersServiceInterface) ListEmailsForUser(user int, opt *gitlab.ListEmailsForUserOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Email, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListEmailsForUser", varargs...)
	ret0, _ := ret[0].([]*gitlab.Email)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListEmailsForUser indicates an expected call of ListEmailsForUser.
func (mr *MockUsersServiceInterfaceMockRecorder) ListEmailsForUser(user, opt any, options ...any) *MockUsersServiceInterfaceListEmailsForUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListEmailsForUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).ListEmailsForUser), varargs...)
	return &MockUsersServiceInterfaceListEmailsForUserCall{Call: call}
}

// MockUsersServiceInterfaceListEmailsForUserCall wrap *gomock.Call
type MockUsersServiceInterfaceListEmailsForUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceListEmailsForUserCall) Return(arg0 []*gitlab.Email, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceListEmailsForUserCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceListEmailsForUserCall) Do(f func(int, *gitlab.ListEmailsForUserOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Email, *gitlab.Response, error)) *MockUsersServiceInterfaceListEmailsForUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceListEmailsForUserCall) DoAndReturn(f func(int, *gitlab.ListEmailsForUserOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Email, *gitlab.Response, error)) *MockUsersServiceInterfaceListEmailsForUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListGPGKeys mocks base method.
func (m *MockUsersServiceInterface) ListGPGKeys(options ...gitlab.RequestOptionFunc) ([]*gitlab.GPGKey, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListGPGKeys", varargs...)
	ret0, _ := ret[0].([]*gitlab.GPGKey)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListGPGKeys indicates an expected call of ListGPGKeys.
func (mr *MockUsersServiceInterfaceMockRecorder) ListGPGKeys(options ...any) *MockUsersServiceInterfaceListGPGKeysCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListGPGKeys", reflect.TypeOf((*MockUsersServiceInterface)(nil).ListGPGKeys), options...)
	return &MockUsersServiceInterfaceListGPGKeysCall{Call: call}
}

// MockUsersServiceInterfaceListGPGKeysCall wrap *gomock.Call
type MockUsersServiceInterfaceListGPGKeysCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceListGPGKeysCall) Return(arg0 []*gitlab.GPGKey, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceListGPGKeysCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceListGPGKeysCall) Do(f func(...gitlab.RequestOptionFunc) ([]*gitlab.GPGKey, *gitlab.Response, error)) *MockUsersServiceInterfaceListGPGKeysCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceListGPGKeysCall) DoAndReturn(f func(...gitlab.RequestOptionFunc) ([]*gitlab.GPGKey, *gitlab.Response, error)) *MockUsersServiceInterfaceListGPGKeysCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListGPGKeysForUser mocks base method.
func (m *MockUsersServiceInterface) ListGPGKeysForUser(user int, options ...gitlab.RequestOptionFunc) ([]*gitlab.GPGKey, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListGPGKeysForUser", varargs...)
	ret0, _ := ret[0].([]*gitlab.GPGKey)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListGPGKeysForUser indicates an expected call of ListGPGKeysForUser.
func (mr *MockUsersServiceInterfaceMockRecorder) ListGPGKeysForUser(user any, options ...any) *MockUsersServiceInterfaceListGPGKeysForUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListGPGKeysForUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).ListGPGKeysForUser), varargs...)
	return &MockUsersServiceInterfaceListGPGKeysForUserCall{Call: call}
}

// MockUsersServiceInterfaceListGPGKeysForUserCall wrap *gomock.Call
type MockUsersServiceInterfaceListGPGKeysForUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceListGPGKeysForUserCall) Return(arg0 []*gitlab.GPGKey, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceListGPGKeysForUserCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceListGPGKeysForUserCall) Do(f func(int, ...gitlab.RequestOptionFunc) ([]*gitlab.GPGKey, *gitlab.Response, error)) *MockUsersServiceInterfaceListGPGKeysForUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceListGPGKeysForUserCall) DoAndReturn(f func(int, ...gitlab.RequestOptionFunc) ([]*gitlab.GPGKey, *gitlab.Response, error)) *MockUsersServiceInterfaceListGPGKeysForUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListSSHKeys mocks base method.
func (m *MockUsersServiceInterface) ListSSHKeys(opt *gitlab.ListSSHKeysOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.SSHKey, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListSSHKeys", varargs...)
	ret0, _ := ret[0].([]*gitlab.SSHKey)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListSSHKeys indicates an expected call of ListSSHKeys.
func (mr *MockUsersServiceInterfaceMockRecorder) ListSSHKeys(opt any, options ...any) *MockUsersServiceInterfaceListSSHKeysCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListSSHKeys", reflect.TypeOf((*MockUsersServiceInterface)(nil).ListSSHKeys), varargs...)
	return &MockUsersServiceInterfaceListSSHKeysCall{Call: call}
}

// MockUsersServiceInterfaceListSSHKeysCall wrap *gomock.Call
type MockUsersServiceInterfaceListSSHKeysCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceListSSHKeysCall) Return(arg0 []*gitlab.SSHKey, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceListSSHKeysCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceListSSHKeysCall) Do(f func(*gitlab.ListSSHKeysOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.SSHKey, *gitlab.Response, error)) *MockUsersServiceInterfaceListSSHKeysCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceListSSHKeysCall) DoAndReturn(f func(*gitlab.ListSSHKeysOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.SSHKey, *gitlab.Response, error)) *MockUsersServiceInterfaceListSSHKeysCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListSSHKeysForUser mocks base method.
func (m *MockUsersServiceInterface) ListSSHKeysForUser(uid any, opt *gitlab.ListSSHKeysForUserOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.SSHKey, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{uid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListSSHKeysForUser", varargs...)
	ret0, _ := ret[0].([]*gitlab.SSHKey)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListSSHKeysForUser indicates an expected call of ListSSHKeysForUser.
func (mr *MockUsersServiceInterfaceMockRecorder) ListSSHKeysForUser(uid, opt any, options ...any) *MockUsersServiceInterfaceListSSHKeysForUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{uid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListSSHKeysForUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).ListSSHKeysForUser), varargs...)
	return &MockUsersServiceInterfaceListSSHKeysForUserCall{Call: call}
}

// MockUsersServiceInterfaceListSSHKeysForUserCall wrap *gomock.Call
type MockUsersServiceInterfaceListSSHKeysForUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceListSSHKeysForUserCall) Return(arg0 []*gitlab.SSHKey, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceListSSHKeysForUserCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceListSSHKeysForUserCall) Do(f func(any, *gitlab.ListSSHKeysForUserOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.SSHKey, *gitlab.Response, error)) *MockUsersServiceInterfaceListSSHKeysForUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceListSSHKeysForUserCall) DoAndReturn(f func(any, *gitlab.ListSSHKeysForUserOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.SSHKey, *gitlab.Response, error)) *MockUsersServiceInterfaceListSSHKeysForUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListServiceAccounts mocks base method.
func (m *MockUsersServiceInterface) ListServiceAccounts(opt *gitlab.ListServiceAccountsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.ServiceAccount, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListServiceAccounts", varargs...)
	ret0, _ := ret[0].([]*gitlab.ServiceAccount)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListServiceAccounts indicates an expected call of ListServiceAccounts.
func (mr *MockUsersServiceInterfaceMockRecorder) ListServiceAccounts(opt any, options ...any) *MockUsersServiceInterfaceListServiceAccountsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListServiceAccounts", reflect.TypeOf((*MockUsersServiceInterface)(nil).ListServiceAccounts), varargs...)
	return &MockUsersServiceInterfaceListServiceAccountsCall{Call: call}
}

// MockUsersServiceInterfaceListServiceAccountsCall wrap *gomock.Call
type MockUsersServiceInterfaceListServiceAccountsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceListServiceAccountsCall) Return(arg0 []*gitlab.ServiceAccount, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceListServiceAccountsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceListServiceAccountsCall) Do(f func(*gitlab.ListServiceAccountsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ServiceAccount, *gitlab.Response, error)) *MockUsersServiceInterfaceListServiceAccountsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceListServiceAccountsCall) DoAndReturn(f func(*gitlab.ListServiceAccountsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ServiceAccount, *gitlab.Response, error)) *MockUsersServiceInterfaceListServiceAccountsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListUserContributionEvents mocks base method.
func (m *MockUsersServiceInterface) ListUserContributionEvents(uid any, opt *gitlab.ListContributionEventsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.ContributionEvent, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{uid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListUserContributionEvents", varargs...)
	ret0, _ := ret[0].([]*gitlab.ContributionEvent)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListUserContributionEvents indicates an expected call of ListUserContributionEvents.
func (mr *MockUsersServiceInterfaceMockRecorder) ListUserContributionEvents(uid, opt any, options ...any) *MockUsersServiceInterfaceListUserContributionEventsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{uid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListUserContributionEvents", reflect.TypeOf((*MockUsersServiceInterface)(nil).ListUserContributionEvents), varargs...)
	return &MockUsersServiceInterfaceListUserContributionEventsCall{Call: call}
}

// MockUsersServiceInterfaceListUserContributionEventsCall wrap *gomock.Call
type MockUsersServiceInterfaceListUserContributionEventsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceListUserContributionEventsCall) Return(arg0 []*gitlab.ContributionEvent, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceListUserContributionEventsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceListUserContributionEventsCall) Do(f func(any, *gitlab.ListContributionEventsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ContributionEvent, *gitlab.Response, error)) *MockUsersServiceInterfaceListUserContributionEventsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceListUserContributionEventsCall) DoAndReturn(f func(any, *gitlab.ListContributionEventsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ContributionEvent, *gitlab.Response, error)) *MockUsersServiceInterfaceListUserContributionEventsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListUsers mocks base method.
func (m *MockUsersServiceInterface) ListUsers(opt *gitlab.ListUsersOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListUsers", varargs...)
	ret0, _ := ret[0].([]*gitlab.User)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListUsers indicates an expected call of ListUsers.
func (mr *MockUsersServiceInterfaceMockRecorder) ListUsers(opt any, options ...any) *MockUsersServiceInterfaceListUsersCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListUsers", reflect.TypeOf((*MockUsersServiceInterface)(nil).ListUsers), varargs...)
	return &MockUsersServiceInterfaceListUsersCall{Call: call}
}

// MockUsersServiceInterfaceListUsersCall wrap *gomock.Call
type MockUsersServiceInterfaceListUsersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceListUsersCall) Return(arg0 []*gitlab.User, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceListUsersCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceListUsersCall) Do(f func(*gitlab.ListUsersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error)) *MockUsersServiceInterfaceListUsersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceListUsersCall) DoAndReturn(f func(*gitlab.ListUsersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error)) *MockUsersServiceInterfaceListUsersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ModifyUser mocks base method.
func (m *MockUsersServiceInterface) ModifyUser(user int, opt *gitlab.ModifyUserOptions, options ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ModifyUser", varargs...)
	ret0, _ := ret[0].(*gitlab.User)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ModifyUser indicates an expected call of ModifyUser.
func (mr *MockUsersServiceInterfaceMockRecorder) ModifyUser(user, opt any, options ...any) *MockUsersServiceInterfaceModifyUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ModifyUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).ModifyUser), varargs...)
	return &MockUsersServiceInterfaceModifyUserCall{Call: call}
}

// MockUsersServiceInterfaceModifyUserCall wrap *gomock.Call
type MockUsersServiceInterfaceModifyUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceModifyUserCall) Return(arg0 *gitlab.User, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceModifyUserCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceModifyUserCall) Do(f func(int, *gitlab.ModifyUserOptions, ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)) *MockUsersServiceInterfaceModifyUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceModifyUserCall) DoAndReturn(f func(int, *gitlab.ModifyUserOptions, ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)) *MockUsersServiceInterfaceModifyUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RejectUser mocks base method.
func (m *MockUsersServiceInterface) RejectUser(user int, options ...gitlab.RequestOptionFunc) error {
	m.ctrl.T.Helper()
	varargs := []any{user}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RejectUser", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// RejectUser indicates an expected call of RejectUser.
func (mr *MockUsersServiceInterfaceMockRecorder) RejectUser(user any, options ...any) *MockUsersServiceInterfaceRejectUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RejectUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).RejectUser), varargs...)
	return &MockUsersServiceInterfaceRejectUserCall{Call: call}
}

// MockUsersServiceInterfaceRejectUserCall wrap *gomock.Call
type MockUsersServiceInterfaceRejectUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceRejectUserCall) Return(arg0 error) *MockUsersServiceInterfaceRejectUserCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceRejectUserCall) Do(f func(int, ...gitlab.RequestOptionFunc) error) *MockUsersServiceInterfaceRejectUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceRejectUserCall) DoAndReturn(f func(int, ...gitlab.RequestOptionFunc) error) *MockUsersServiceInterfaceRejectUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RevokeImpersonationToken mocks base method.
func (m *MockUsersServiceInterface) RevokeImpersonationToken(user, token int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user, token}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RevokeImpersonationToken", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RevokeImpersonationToken indicates an expected call of RevokeImpersonationToken.
func (mr *MockUsersServiceInterfaceMockRecorder) RevokeImpersonationToken(user, token any, options ...any) *MockUsersServiceInterfaceRevokeImpersonationTokenCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user, token}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RevokeImpersonationToken", reflect.TypeOf((*MockUsersServiceInterface)(nil).RevokeImpersonationToken), varargs...)
	return &MockUsersServiceInterfaceRevokeImpersonationTokenCall{Call: call}
}

// MockUsersServiceInterfaceRevokeImpersonationTokenCall wrap *gomock.Call
type MockUsersServiceInterfaceRevokeImpersonationTokenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceRevokeImpersonationTokenCall) Return(arg0 *gitlab.Response, arg1 error) *MockUsersServiceInterfaceRevokeImpersonationTokenCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceRevokeImpersonationTokenCall) Do(f func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockUsersServiceInterfaceRevokeImpersonationTokenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceRevokeImpersonationTokenCall) DoAndReturn(f func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockUsersServiceInterfaceRevokeImpersonationTokenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetUserStatus mocks base method.
func (m *MockUsersServiceInterface) SetUserStatus(opt *gitlab.UserStatusOptions, options ...gitlab.RequestOptionFunc) (*gitlab.UserStatus, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SetUserStatus", varargs...)
	ret0, _ := ret[0].(*gitlab.UserStatus)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// SetUserStatus indicates an expected call of SetUserStatus.
func (mr *MockUsersServiceInterfaceMockRecorder) SetUserStatus(opt any, options ...any) *MockUsersServiceInterfaceSetUserStatusCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetUserStatus", reflect.TypeOf((*MockUsersServiceInterface)(nil).SetUserStatus), varargs...)
	return &MockUsersServiceInterfaceSetUserStatusCall{Call: call}
}

// MockUsersServiceInterfaceSetUserStatusCall wrap *gomock.Call
type MockUsersServiceInterfaceSetUserStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceSetUserStatusCall) Return(arg0 *gitlab.UserStatus, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceSetUserStatusCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceSetUserStatusCall) Do(f func(*gitlab.UserStatusOptions, ...gitlab.RequestOptionFunc) (*gitlab.UserStatus, *gitlab.Response, error)) *MockUsersServiceInterfaceSetUserStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceSetUserStatusCall) DoAndReturn(f func(*gitlab.UserStatusOptions, ...gitlab.RequestOptionFunc) (*gitlab.UserStatus, *gitlab.Response, error)) *MockUsersServiceInterfaceSetUserStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnbanUser mocks base method.
func (m *MockUsersServiceInterface) UnbanUser(user int, options ...gitlab.RequestOptionFunc) error {
	m.ctrl.T.Helper()
	varargs := []any{user}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UnbanUser", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UnbanUser indicates an expected call of UnbanUser.
func (mr *MockUsersServiceInterfaceMockRecorder) UnbanUser(user any, options ...any) *MockUsersServiceInterfaceUnbanUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnbanUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).UnbanUser), varargs...)
	return &MockUsersServiceInterfaceUnbanUserCall{Call: call}
}

// MockUsersServiceInterfaceUnbanUserCall wrap *gomock.Call
type MockUsersServiceInterfaceUnbanUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceUnbanUserCall) Return(arg0 error) *MockUsersServiceInterfaceUnbanUserCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceUnbanUserCall) Do(f func(int, ...gitlab.RequestOptionFunc) error) *MockUsersServiceInterfaceUnbanUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceUnbanUserCall) DoAndReturn(f func(int, ...gitlab.RequestOptionFunc) error) *MockUsersServiceInterfaceUnbanUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnblockUser mocks base method.
func (m *MockUsersServiceInterface) UnblockUser(user int, options ...gitlab.RequestOptionFunc) error {
	m.ctrl.T.Helper()
	varargs := []any{user}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UnblockUser", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UnblockUser indicates an expected call of UnblockUser.
func (mr *MockUsersServiceInterfaceMockRecorder) UnblockUser(user any, options ...any) *MockUsersServiceInterfaceUnblockUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnblockUser", reflect.TypeOf((*MockUsersServiceInterface)(nil).UnblockUser), varargs...)
	return &MockUsersServiceInterfaceUnblockUserCall{Call: call}
}

// MockUsersServiceInterfaceUnblockUserCall wrap *gomock.Call
type MockUsersServiceInterfaceUnblockUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceUnblockUserCall) Return(arg0 error) *MockUsersServiceInterfaceUnblockUserCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceUnblockUserCall) Do(f func(int, ...gitlab.RequestOptionFunc) error) *MockUsersServiceInterfaceUnblockUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceUnblockUserCall) DoAndReturn(f func(int, ...gitlab.RequestOptionFunc) error) *MockUsersServiceInterfaceUnblockUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UploadAvatar mocks base method.
func (m *MockUsersServiceInterface) UploadAvatar(avatar io.Reader, filename string, options ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{avatar, filename}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UploadAvatar", varargs...)
	ret0, _ := ret[0].(*gitlab.User)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// UploadAvatar indicates an expected call of UploadAvatar.
func (mr *MockUsersServiceInterfaceMockRecorder) UploadAvatar(avatar, filename any, options ...any) *MockUsersServiceInterfaceUploadAvatarCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{avatar, filename}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UploadAvatar", reflect.TypeOf((*MockUsersServiceInterface)(nil).UploadAvatar), varargs...)
	return &MockUsersServiceInterfaceUploadAvatarCall{Call: call}
}

// MockUsersServiceInterfaceUploadAvatarCall wrap *gomock.Call
type MockUsersServiceInterfaceUploadAvatarCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUsersServiceInterfaceUploadAvatarCall) Return(arg0 *gitlab.User, arg1 *gitlab.Response, arg2 error) *MockUsersServiceInterfaceUploadAvatarCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUsersServiceInterfaceUploadAvatarCall) Do(f func(io.Reader, string, ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)) *MockUsersServiceInterfaceUploadAvatarCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUsersServiceInterfaceUploadAvatarCall) DoAndReturn(f func(io.Reader, string, ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)) *MockUsersServiceInterfaceUploadAvatarCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
