// Code generated by MockGen. DO NOT EDIT.
// Source: gitlab.com/gitlab-org/api/client-go (interfaces: PackagesServiceInterface)
//
// Generated by this command:
//
//	mockgen -typed -destination=packages_mock.go -write_package_comment=false -package=testing gitlab.com/gitlab-org/api/client-go PackagesServiceInterface
//

package testing

import (
	reflect "reflect"

	gitlab "gitlab.com/gitlab-org/api/client-go"
	gomock "go.uber.org/mock/gomock"
)

// MockPackagesServiceInterface is a mock of PackagesServiceInterface interface.
type MockPackagesServiceInterface struct {
	ctrl     *gomock.Controller
	recorder *MockPackagesServiceInterfaceMockRecorder
	isgomock struct{}
}

// MockPackagesServiceInterfaceMockRecorder is the mock recorder for MockPackagesServiceInterface.
type MockPackagesServiceInterfaceMockRecorder struct {
	mock *MockPackagesServiceInterface
}

// NewMockPackagesServiceInterface creates a new mock instance.
func NewMockPackagesServiceInterface(ctrl *gomock.Controller) *MockPackagesServiceInterface {
	mock := &MockPackagesServiceInterface{ctrl: ctrl}
	mock.recorder = &MockPackagesServiceInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPackagesServiceInterface) EXPECT() *MockPackagesServiceInterfaceMockRecorder {
	return m.recorder
}

// DeletePackageFile mocks base method.
func (m *MockPackagesServiceInterface) DeletePackageFile(pid any, pkg, file int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, pkg, file}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeletePackageFile", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeletePackageFile indicates an expected call of DeletePackageFile.
func (mr *MockPackagesServiceInterfaceMockRecorder) DeletePackageFile(pid, pkg, file any, options ...any) *MockPackagesServiceInterfaceDeletePackageFileCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, pkg, file}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeletePackageFile", reflect.TypeOf((*MockPackagesServiceInterface)(nil).DeletePackageFile), varargs...)
	return &MockPackagesServiceInterfaceDeletePackageFileCall{Call: call}
}

// MockPackagesServiceInterfaceDeletePackageFileCall wrap *gomock.Call
type MockPackagesServiceInterfaceDeletePackageFileCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPackagesServiceInterfaceDeletePackageFileCall) Return(arg0 *gitlab.Response, arg1 error) *MockPackagesServiceInterfaceDeletePackageFileCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPackagesServiceInterfaceDeletePackageFileCall) Do(f func(any, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockPackagesServiceInterfaceDeletePackageFileCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPackagesServiceInterfaceDeletePackageFileCall) DoAndReturn(f func(any, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockPackagesServiceInterfaceDeletePackageFileCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteProjectPackage mocks base method.
func (m *MockPackagesServiceInterface) DeleteProjectPackage(pid any, pkg int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, pkg}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteProjectPackage", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteProjectPackage indicates an expected call of DeleteProjectPackage.
func (mr *MockPackagesServiceInterfaceMockRecorder) DeleteProjectPackage(pid, pkg any, options ...any) *MockPackagesServiceInterfaceDeleteProjectPackageCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, pkg}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteProjectPackage", reflect.TypeOf((*MockPackagesServiceInterface)(nil).DeleteProjectPackage), varargs...)
	return &MockPackagesServiceInterfaceDeleteProjectPackageCall{Call: call}
}

// MockPackagesServiceInterfaceDeleteProjectPackageCall wrap *gomock.Call
type MockPackagesServiceInterfaceDeleteProjectPackageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPackagesServiceInterfaceDeleteProjectPackageCall) Return(arg0 *gitlab.Response, arg1 error) *MockPackagesServiceInterfaceDeleteProjectPackageCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPackagesServiceInterfaceDeleteProjectPackageCall) Do(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockPackagesServiceInterfaceDeleteProjectPackageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPackagesServiceInterfaceDeleteProjectPackageCall) DoAndReturn(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockPackagesServiceInterfaceDeleteProjectPackageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListGroupPackages mocks base method.
func (m *MockPackagesServiceInterface) ListGroupPackages(gid any, opt *gitlab.ListGroupPackagesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.GroupPackage, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{gid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListGroupPackages", varargs...)
	ret0, _ := ret[0].([]*gitlab.GroupPackage)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListGroupPackages indicates an expected call of ListGroupPackages.
func (mr *MockPackagesServiceInterfaceMockRecorder) ListGroupPackages(gid, opt any, options ...any) *MockPackagesServiceInterfaceListGroupPackagesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{gid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListGroupPackages", reflect.TypeOf((*MockPackagesServiceInterface)(nil).ListGroupPackages), varargs...)
	return &MockPackagesServiceInterfaceListGroupPackagesCall{Call: call}
}

// MockPackagesServiceInterfaceListGroupPackagesCall wrap *gomock.Call
type MockPackagesServiceInterfaceListGroupPackagesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPackagesServiceInterfaceListGroupPackagesCall) Return(arg0 []*gitlab.GroupPackage, arg1 *gitlab.Response, arg2 error) *MockPackagesServiceInterfaceListGroupPackagesCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPackagesServiceInterfaceListGroupPackagesCall) Do(f func(any, *gitlab.ListGroupPackagesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.GroupPackage, *gitlab.Response, error)) *MockPackagesServiceInterfaceListGroupPackagesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPackagesServiceInterfaceListGroupPackagesCall) DoAndReturn(f func(any, *gitlab.ListGroupPackagesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.GroupPackage, *gitlab.Response, error)) *MockPackagesServiceInterfaceListGroupPackagesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListPackageFiles mocks base method.
func (m *MockPackagesServiceInterface) ListPackageFiles(pid any, pkg int, opt *gitlab.ListPackageFilesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.PackageFile, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, pkg, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListPackageFiles", varargs...)
	ret0, _ := ret[0].([]*gitlab.PackageFile)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListPackageFiles indicates an expected call of ListPackageFiles.
func (mr *MockPackagesServiceInterfaceMockRecorder) ListPackageFiles(pid, pkg, opt any, options ...any) *MockPackagesServiceInterfaceListPackageFilesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, pkg, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListPackageFiles", reflect.TypeOf((*MockPackagesServiceInterface)(nil).ListPackageFiles), varargs...)
	return &MockPackagesServiceInterfaceListPackageFilesCall{Call: call}
}

// MockPackagesServiceInterfaceListPackageFilesCall wrap *gomock.Call
type MockPackagesServiceInterfaceListPackageFilesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPackagesServiceInterfaceListPackageFilesCall) Return(arg0 []*gitlab.PackageFile, arg1 *gitlab.Response, arg2 error) *MockPackagesServiceInterfaceListPackageFilesCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPackagesServiceInterfaceListPackageFilesCall) Do(f func(any, int, *gitlab.ListPackageFilesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.PackageFile, *gitlab.Response, error)) *MockPackagesServiceInterfaceListPackageFilesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPackagesServiceInterfaceListPackageFilesCall) DoAndReturn(f func(any, int, *gitlab.ListPackageFilesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.PackageFile, *gitlab.Response, error)) *MockPackagesServiceInterfaceListPackageFilesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListProjectPackages mocks base method.
func (m *MockPackagesServiceInterface) ListProjectPackages(pid any, opt *gitlab.ListProjectPackagesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Package, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListProjectPackages", varargs...)
	ret0, _ := ret[0].([]*gitlab.Package)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListProjectPackages indicates an expected call of ListProjectPackages.
func (mr *MockPackagesServiceInterfaceMockRecorder) ListProjectPackages(pid, opt any, options ...any) *MockPackagesServiceInterfaceListProjectPackagesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListProjectPackages", reflect.TypeOf((*MockPackagesServiceInterface)(nil).ListProjectPackages), varargs...)
	return &MockPackagesServiceInterfaceListProjectPackagesCall{Call: call}
}

// MockPackagesServiceInterfaceListProjectPackagesCall wrap *gomock.Call
type MockPackagesServiceInterfaceListProjectPackagesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPackagesServiceInterfaceListProjectPackagesCall) Return(arg0 []*gitlab.Package, arg1 *gitlab.Response, arg2 error) *MockPackagesServiceInterfaceListProjectPackagesCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPackagesServiceInterfaceListProjectPackagesCall) Do(f func(any, *gitlab.ListProjectPackagesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Package, *gitlab.Response, error)) *MockPackagesServiceInterfaceListProjectPackagesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPackagesServiceInterfaceListProjectPackagesCall) DoAndReturn(f func(any, *gitlab.ListProjectPackagesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Package, *gitlab.Response, error)) *MockPackagesServiceInterfaceListProjectPackagesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
