// Code generated by MockGen. DO NOT EDIT.
// Source: gitlab.com/gitlab-org/api/client-go (interfaces: RunnersServiceInterface)
//
// Generated by this command:
//
//	mockgen -typed -destination=runners_mock.go -write_package_comment=false -package=testing gitlab.com/gitlab-org/api/client-go RunnersServiceInterface
//

package testing

import (
	reflect "reflect"

	gitlab "gitlab.com/gitlab-org/api/client-go"
	gomock "go.uber.org/mock/gomock"
)

// MockRunnersServiceInterface is a mock of RunnersServiceInterface interface.
type MockRunnersServiceInterface struct {
	ctrl     *gomock.Controller
	recorder *MockRunnersServiceInterfaceMockRecorder
	isgomock struct{}
}

// MockRunnersServiceInterfaceMockRecorder is the mock recorder for MockRunnersServiceInterface.
type MockRunnersServiceInterfaceMockRecorder struct {
	mock *MockRunnersServiceInterface
}

// NewMockRunnersServiceInterface creates a new mock instance.
func NewMockRunnersServiceInterface(ctrl *gomock.Controller) *MockRunnersServiceInterface {
	mock := &MockRunnersServiceInterface{ctrl: ctrl}
	mock.recorder = &MockRunnersServiceInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRunnersServiceInterface) EXPECT() *MockRunnersServiceInterfaceMockRecorder {
	return m.recorder
}

// DeleteRegisteredRunner mocks base method.
func (m *MockRunnersServiceInterface) DeleteRegisteredRunner(opt *gitlab.DeleteRegisteredRunnerOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteRegisteredRunner", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteRegisteredRunner indicates an expected call of DeleteRegisteredRunner.
func (mr *MockRunnersServiceInterfaceMockRecorder) DeleteRegisteredRunner(opt any, options ...any) *MockRunnersServiceInterfaceDeleteRegisteredRunnerCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteRegisteredRunner", reflect.TypeOf((*MockRunnersServiceInterface)(nil).DeleteRegisteredRunner), varargs...)
	return &MockRunnersServiceInterfaceDeleteRegisteredRunnerCall{Call: call}
}

// MockRunnersServiceInterfaceDeleteRegisteredRunnerCall wrap *gomock.Call
type MockRunnersServiceInterfaceDeleteRegisteredRunnerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnersServiceInterfaceDeleteRegisteredRunnerCall) Return(arg0 *gitlab.Response, arg1 error) *MockRunnersServiceInterfaceDeleteRegisteredRunnerCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnersServiceInterfaceDeleteRegisteredRunnerCall) Do(f func(*gitlab.DeleteRegisteredRunnerOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockRunnersServiceInterfaceDeleteRegisteredRunnerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnersServiceInterfaceDeleteRegisteredRunnerCall) DoAndReturn(f func(*gitlab.DeleteRegisteredRunnerOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockRunnersServiceInterfaceDeleteRegisteredRunnerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteRegisteredRunnerByID mocks base method.
func (m *MockRunnersServiceInterface) DeleteRegisteredRunnerByID(rid int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{rid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteRegisteredRunnerByID", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteRegisteredRunnerByID indicates an expected call of DeleteRegisteredRunnerByID.
func (mr *MockRunnersServiceInterfaceMockRecorder) DeleteRegisteredRunnerByID(rid any, options ...any) *MockRunnersServiceInterfaceDeleteRegisteredRunnerByIDCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{rid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteRegisteredRunnerByID", reflect.TypeOf((*MockRunnersServiceInterface)(nil).DeleteRegisteredRunnerByID), varargs...)
	return &MockRunnersServiceInterfaceDeleteRegisteredRunnerByIDCall{Call: call}
}

// MockRunnersServiceInterfaceDeleteRegisteredRunnerByIDCall wrap *gomock.Call
type MockRunnersServiceInterfaceDeleteRegisteredRunnerByIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnersServiceInterfaceDeleteRegisteredRunnerByIDCall) Return(arg0 *gitlab.Response, arg1 error) *MockRunnersServiceInterfaceDeleteRegisteredRunnerByIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnersServiceInterfaceDeleteRegisteredRunnerByIDCall) Do(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockRunnersServiceInterfaceDeleteRegisteredRunnerByIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnersServiceInterfaceDeleteRegisteredRunnerByIDCall) DoAndReturn(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockRunnersServiceInterfaceDeleteRegisteredRunnerByIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DisableProjectRunner mocks base method.
func (m *MockRunnersServiceInterface) DisableProjectRunner(pid any, runner int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, runner}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DisableProjectRunner", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DisableProjectRunner indicates an expected call of DisableProjectRunner.
func (mr *MockRunnersServiceInterfaceMockRecorder) DisableProjectRunner(pid, runner any, options ...any) *MockRunnersServiceInterfaceDisableProjectRunnerCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, runner}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DisableProjectRunner", reflect.TypeOf((*MockRunnersServiceInterface)(nil).DisableProjectRunner), varargs...)
	return &MockRunnersServiceInterfaceDisableProjectRunnerCall{Call: call}
}

// MockRunnersServiceInterfaceDisableProjectRunnerCall wrap *gomock.Call
type MockRunnersServiceInterfaceDisableProjectRunnerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnersServiceInterfaceDisableProjectRunnerCall) Return(arg0 *gitlab.Response, arg1 error) *MockRunnersServiceInterfaceDisableProjectRunnerCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnersServiceInterfaceDisableProjectRunnerCall) Do(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockRunnersServiceInterfaceDisableProjectRunnerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnersServiceInterfaceDisableProjectRunnerCall) DoAndReturn(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockRunnersServiceInterfaceDisableProjectRunnerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// EnableProjectRunner mocks base method.
func (m *MockRunnersServiceInterface) EnableProjectRunner(pid any, opt *gitlab.EnableProjectRunnerOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Runner, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "EnableProjectRunner", varargs...)
	ret0, _ := ret[0].(*gitlab.Runner)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// EnableProjectRunner indicates an expected call of EnableProjectRunner.
func (mr *MockRunnersServiceInterfaceMockRecorder) EnableProjectRunner(pid, opt any, options ...any) *MockRunnersServiceInterfaceEnableProjectRunnerCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnableProjectRunner", reflect.TypeOf((*MockRunnersServiceInterface)(nil).EnableProjectRunner), varargs...)
	return &MockRunnersServiceInterfaceEnableProjectRunnerCall{Call: call}
}

// MockRunnersServiceInterfaceEnableProjectRunnerCall wrap *gomock.Call
type MockRunnersServiceInterfaceEnableProjectRunnerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnersServiceInterfaceEnableProjectRunnerCall) Return(arg0 *gitlab.Runner, arg1 *gitlab.Response, arg2 error) *MockRunnersServiceInterfaceEnableProjectRunnerCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnersServiceInterfaceEnableProjectRunnerCall) Do(f func(any, *gitlab.EnableProjectRunnerOptions, ...gitlab.RequestOptionFunc) (*gitlab.Runner, *gitlab.Response, error)) *MockRunnersServiceInterfaceEnableProjectRunnerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnersServiceInterfaceEnableProjectRunnerCall) DoAndReturn(f func(any, *gitlab.EnableProjectRunnerOptions, ...gitlab.RequestOptionFunc) (*gitlab.Runner, *gitlab.Response, error)) *MockRunnersServiceInterfaceEnableProjectRunnerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetRunnerDetails mocks base method.
func (m *MockRunnersServiceInterface) GetRunnerDetails(rid any, options ...gitlab.RequestOptionFunc) (*gitlab.RunnerDetails, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{rid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetRunnerDetails", varargs...)
	ret0, _ := ret[0].(*gitlab.RunnerDetails)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetRunnerDetails indicates an expected call of GetRunnerDetails.
func (mr *MockRunnersServiceInterfaceMockRecorder) GetRunnerDetails(rid any, options ...any) *MockRunnersServiceInterfaceGetRunnerDetailsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{rid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRunnerDetails", reflect.TypeOf((*MockRunnersServiceInterface)(nil).GetRunnerDetails), varargs...)
	return &MockRunnersServiceInterfaceGetRunnerDetailsCall{Call: call}
}

// MockRunnersServiceInterfaceGetRunnerDetailsCall wrap *gomock.Call
type MockRunnersServiceInterfaceGetRunnerDetailsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnersServiceInterfaceGetRunnerDetailsCall) Return(arg0 *gitlab.RunnerDetails, arg1 *gitlab.Response, arg2 error) *MockRunnersServiceInterfaceGetRunnerDetailsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnersServiceInterfaceGetRunnerDetailsCall) Do(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.RunnerDetails, *gitlab.Response, error)) *MockRunnersServiceInterfaceGetRunnerDetailsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnersServiceInterfaceGetRunnerDetailsCall) DoAndReturn(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.RunnerDetails, *gitlab.Response, error)) *MockRunnersServiceInterfaceGetRunnerDetailsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListAllRunners mocks base method.
func (m *MockRunnersServiceInterface) ListAllRunners(opt *gitlab.ListRunnersOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListAllRunners", varargs...)
	ret0, _ := ret[0].([]*gitlab.Runner)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListAllRunners indicates an expected call of ListAllRunners.
func (mr *MockRunnersServiceInterfaceMockRecorder) ListAllRunners(opt any, options ...any) *MockRunnersServiceInterfaceListAllRunnersCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAllRunners", reflect.TypeOf((*MockRunnersServiceInterface)(nil).ListAllRunners), varargs...)
	return &MockRunnersServiceInterfaceListAllRunnersCall{Call: call}
}

// MockRunnersServiceInterfaceListAllRunnersCall wrap *gomock.Call
type MockRunnersServiceInterfaceListAllRunnersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnersServiceInterfaceListAllRunnersCall) Return(arg0 []*gitlab.Runner, arg1 *gitlab.Response, arg2 error) *MockRunnersServiceInterfaceListAllRunnersCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnersServiceInterfaceListAllRunnersCall) Do(f func(*gitlab.ListRunnersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error)) *MockRunnersServiceInterfaceListAllRunnersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnersServiceInterfaceListAllRunnersCall) DoAndReturn(f func(*gitlab.ListRunnersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error)) *MockRunnersServiceInterfaceListAllRunnersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListGroupsRunners mocks base method.
func (m *MockRunnersServiceInterface) ListGroupsRunners(gid any, opt *gitlab.ListGroupsRunnersOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{gid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListGroupsRunners", varargs...)
	ret0, _ := ret[0].([]*gitlab.Runner)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListGroupsRunners indicates an expected call of ListGroupsRunners.
func (mr *MockRunnersServiceInterfaceMockRecorder) ListGroupsRunners(gid, opt any, options ...any) *MockRunnersServiceInterfaceListGroupsRunnersCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{gid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListGroupsRunners", reflect.TypeOf((*MockRunnersServiceInterface)(nil).ListGroupsRunners), varargs...)
	return &MockRunnersServiceInterfaceListGroupsRunnersCall{Call: call}
}

// MockRunnersServiceInterfaceListGroupsRunnersCall wrap *gomock.Call
type MockRunnersServiceInterfaceListGroupsRunnersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnersServiceInterfaceListGroupsRunnersCall) Return(arg0 []*gitlab.Runner, arg1 *gitlab.Response, arg2 error) *MockRunnersServiceInterfaceListGroupsRunnersCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnersServiceInterfaceListGroupsRunnersCall) Do(f func(any, *gitlab.ListGroupsRunnersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error)) *MockRunnersServiceInterfaceListGroupsRunnersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnersServiceInterfaceListGroupsRunnersCall) DoAndReturn(f func(any, *gitlab.ListGroupsRunnersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error)) *MockRunnersServiceInterfaceListGroupsRunnersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListProjectRunners mocks base method.
func (m *MockRunnersServiceInterface) ListProjectRunners(pid any, opt *gitlab.ListProjectRunnersOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListProjectRunners", varargs...)
	ret0, _ := ret[0].([]*gitlab.Runner)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListProjectRunners indicates an expected call of ListProjectRunners.
func (mr *MockRunnersServiceInterfaceMockRecorder) ListProjectRunners(pid, opt any, options ...any) *MockRunnersServiceInterfaceListProjectRunnersCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListProjectRunners", reflect.TypeOf((*MockRunnersServiceInterface)(nil).ListProjectRunners), varargs...)
	return &MockRunnersServiceInterfaceListProjectRunnersCall{Call: call}
}

// MockRunnersServiceInterfaceListProjectRunnersCall wrap *gomock.Call
type MockRunnersServiceInterfaceListProjectRunnersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnersServiceInterfaceListProjectRunnersCall) Return(arg0 []*gitlab.Runner, arg1 *gitlab.Response, arg2 error) *MockRunnersServiceInterfaceListProjectRunnersCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnersServiceInterfaceListProjectRunnersCall) Do(f func(any, *gitlab.ListProjectRunnersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error)) *MockRunnersServiceInterfaceListProjectRunnersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnersServiceInterfaceListProjectRunnersCall) DoAndReturn(f func(any, *gitlab.ListProjectRunnersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error)) *MockRunnersServiceInterfaceListProjectRunnersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListRunnerJobs mocks base method.
func (m *MockRunnersServiceInterface) ListRunnerJobs(rid any, opt *gitlab.ListRunnerJobsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Job, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{rid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListRunnerJobs", varargs...)
	ret0, _ := ret[0].([]*gitlab.Job)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListRunnerJobs indicates an expected call of ListRunnerJobs.
func (mr *MockRunnersServiceInterfaceMockRecorder) ListRunnerJobs(rid, opt any, options ...any) *MockRunnersServiceInterfaceListRunnerJobsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{rid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListRunnerJobs", reflect.TypeOf((*MockRunnersServiceInterface)(nil).ListRunnerJobs), varargs...)
	return &MockRunnersServiceInterfaceListRunnerJobsCall{Call: call}
}

// MockRunnersServiceInterfaceListRunnerJobsCall wrap *gomock.Call
type MockRunnersServiceInterfaceListRunnerJobsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnersServiceInterfaceListRunnerJobsCall) Return(arg0 []*gitlab.Job, arg1 *gitlab.Response, arg2 error) *MockRunnersServiceInterfaceListRunnerJobsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnersServiceInterfaceListRunnerJobsCall) Do(f func(any, *gitlab.ListRunnerJobsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Job, *gitlab.Response, error)) *MockRunnersServiceInterfaceListRunnerJobsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnersServiceInterfaceListRunnerJobsCall) DoAndReturn(f func(any, *gitlab.ListRunnerJobsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Job, *gitlab.Response, error)) *MockRunnersServiceInterfaceListRunnerJobsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListRunners mocks base method.
func (m *MockRunnersServiceInterface) ListRunners(opt *gitlab.ListRunnersOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListRunners", varargs...)
	ret0, _ := ret[0].([]*gitlab.Runner)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListRunners indicates an expected call of ListRunners.
func (mr *MockRunnersServiceInterfaceMockRecorder) ListRunners(opt any, options ...any) *MockRunnersServiceInterfaceListRunnersCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListRunners", reflect.TypeOf((*MockRunnersServiceInterface)(nil).ListRunners), varargs...)
	return &MockRunnersServiceInterfaceListRunnersCall{Call: call}
}

// MockRunnersServiceInterfaceListRunnersCall wrap *gomock.Call
type MockRunnersServiceInterfaceListRunnersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnersServiceInterfaceListRunnersCall) Return(arg0 []*gitlab.Runner, arg1 *gitlab.Response, arg2 error) *MockRunnersServiceInterfaceListRunnersCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnersServiceInterfaceListRunnersCall) Do(f func(*gitlab.ListRunnersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error)) *MockRunnersServiceInterfaceListRunnersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnersServiceInterfaceListRunnersCall) DoAndReturn(f func(*gitlab.ListRunnersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error)) *MockRunnersServiceInterfaceListRunnersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RegisterNewRunner mocks base method.
func (m *MockRunnersServiceInterface) RegisterNewRunner(opt *gitlab.RegisterNewRunnerOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Runner, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RegisterNewRunner", varargs...)
	ret0, _ := ret[0].(*gitlab.Runner)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// RegisterNewRunner indicates an expected call of RegisterNewRunner.
func (mr *MockRunnersServiceInterfaceMockRecorder) RegisterNewRunner(opt any, options ...any) *MockRunnersServiceInterfaceRegisterNewRunnerCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterNewRunner", reflect.TypeOf((*MockRunnersServiceInterface)(nil).RegisterNewRunner), varargs...)
	return &MockRunnersServiceInterfaceRegisterNewRunnerCall{Call: call}
}

// MockRunnersServiceInterfaceRegisterNewRunnerCall wrap *gomock.Call
type MockRunnersServiceInterfaceRegisterNewRunnerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnersServiceInterfaceRegisterNewRunnerCall) Return(arg0 *gitlab.Runner, arg1 *gitlab.Response, arg2 error) *MockRunnersServiceInterfaceRegisterNewRunnerCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnersServiceInterfaceRegisterNewRunnerCall) Do(f func(*gitlab.RegisterNewRunnerOptions, ...gitlab.RequestOptionFunc) (*gitlab.Runner, *gitlab.Response, error)) *MockRunnersServiceInterfaceRegisterNewRunnerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnersServiceInterfaceRegisterNewRunnerCall) DoAndReturn(f func(*gitlab.RegisterNewRunnerOptions, ...gitlab.RequestOptionFunc) (*gitlab.Runner, *gitlab.Response, error)) *MockRunnersServiceInterfaceRegisterNewRunnerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoveRunner mocks base method.
func (m *MockRunnersServiceInterface) RemoveRunner(rid any, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{rid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RemoveRunner", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RemoveRunner indicates an expected call of RemoveRunner.
func (mr *MockRunnersServiceInterfaceMockRecorder) RemoveRunner(rid any, options ...any) *MockRunnersServiceInterfaceRemoveRunnerCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{rid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveRunner", reflect.TypeOf((*MockRunnersServiceInterface)(nil).RemoveRunner), varargs...)
	return &MockRunnersServiceInterfaceRemoveRunnerCall{Call: call}
}

// MockRunnersServiceInterfaceRemoveRunnerCall wrap *gomock.Call
type MockRunnersServiceInterfaceRemoveRunnerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnersServiceInterfaceRemoveRunnerCall) Return(arg0 *gitlab.Response, arg1 error) *MockRunnersServiceInterfaceRemoveRunnerCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnersServiceInterfaceRemoveRunnerCall) Do(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockRunnersServiceInterfaceRemoveRunnerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnersServiceInterfaceRemoveRunnerCall) DoAndReturn(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockRunnersServiceInterfaceRemoveRunnerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ResetGroupRunnerRegistrationToken mocks base method.
func (m *MockRunnersServiceInterface) ResetGroupRunnerRegistrationToken(gid any, options ...gitlab.RequestOptionFunc) (*gitlab.RunnerRegistrationToken, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{gid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ResetGroupRunnerRegistrationToken", varargs...)
	ret0, _ := ret[0].(*gitlab.RunnerRegistrationToken)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ResetGroupRunnerRegistrationToken indicates an expected call of ResetGroupRunnerRegistrationToken.
func (mr *MockRunnersServiceInterfaceMockRecorder) ResetGroupRunnerRegistrationToken(gid any, options ...any) *MockRunnersServiceInterfaceResetGroupRunnerRegistrationTokenCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{gid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResetGroupRunnerRegistrationToken", reflect.TypeOf((*MockRunnersServiceInterface)(nil).ResetGroupRunnerRegistrationToken), varargs...)
	return &MockRunnersServiceInterfaceResetGroupRunnerRegistrationTokenCall{Call: call}
}

// MockRunnersServiceInterfaceResetGroupRunnerRegistrationTokenCall wrap *gomock.Call
type MockRunnersServiceInterfaceResetGroupRunnerRegistrationTokenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnersServiceInterfaceResetGroupRunnerRegistrationTokenCall) Return(arg0 *gitlab.RunnerRegistrationToken, arg1 *gitlab.Response, arg2 error) *MockRunnersServiceInterfaceResetGroupRunnerRegistrationTokenCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnersServiceInterfaceResetGroupRunnerRegistrationTokenCall) Do(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.RunnerRegistrationToken, *gitlab.Response, error)) *MockRunnersServiceInterfaceResetGroupRunnerRegistrationTokenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnersServiceInterfaceResetGroupRunnerRegistrationTokenCall) DoAndReturn(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.RunnerRegistrationToken, *gitlab.Response, error)) *MockRunnersServiceInterfaceResetGroupRunnerRegistrationTokenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ResetInstanceRunnerRegistrationToken mocks base method.
func (m *MockRunnersServiceInterface) ResetInstanceRunnerRegistrationToken(options ...gitlab.RequestOptionFunc) (*gitlab.RunnerRegistrationToken, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ResetInstanceRunnerRegistrationToken", varargs...)
	ret0, _ := ret[0].(*gitlab.RunnerRegistrationToken)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ResetInstanceRunnerRegistrationToken indicates an expected call of ResetInstanceRunnerRegistrationToken.
func (mr *MockRunnersServiceInterfaceMockRecorder) ResetInstanceRunnerRegistrationToken(options ...any) *MockRunnersServiceInterfaceResetInstanceRunnerRegistrationTokenCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResetInstanceRunnerRegistrationToken", reflect.TypeOf((*MockRunnersServiceInterface)(nil).ResetInstanceRunnerRegistrationToken), options...)
	return &MockRunnersServiceInterfaceResetInstanceRunnerRegistrationTokenCall{Call: call}
}

// MockRunnersServiceInterfaceResetInstanceRunnerRegistrationTokenCall wrap *gomock.Call
type MockRunnersServiceInterfaceResetInstanceRunnerRegistrationTokenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnersServiceInterfaceResetInstanceRunnerRegistrationTokenCall) Return(arg0 *gitlab.RunnerRegistrationToken, arg1 *gitlab.Response, arg2 error) *MockRunnersServiceInterfaceResetInstanceRunnerRegistrationTokenCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnersServiceInterfaceResetInstanceRunnerRegistrationTokenCall) Do(f func(...gitlab.RequestOptionFunc) (*gitlab.RunnerRegistrationToken, *gitlab.Response, error)) *MockRunnersServiceInterfaceResetInstanceRunnerRegistrationTokenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnersServiceInterfaceResetInstanceRunnerRegistrationTokenCall) DoAndReturn(f func(...gitlab.RequestOptionFunc) (*gitlab.RunnerRegistrationToken, *gitlab.Response, error)) *MockRunnersServiceInterfaceResetInstanceRunnerRegistrationTokenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ResetProjectRunnerRegistrationToken mocks base method.
func (m *MockRunnersServiceInterface) ResetProjectRunnerRegistrationToken(pid any, options ...gitlab.RequestOptionFunc) (*gitlab.RunnerRegistrationToken, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ResetProjectRunnerRegistrationToken", varargs...)
	ret0, _ := ret[0].(*gitlab.RunnerRegistrationToken)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ResetProjectRunnerRegistrationToken indicates an expected call of ResetProjectRunnerRegistrationToken.
func (mr *MockRunnersServiceInterfaceMockRecorder) ResetProjectRunnerRegistrationToken(pid any, options ...any) *MockRunnersServiceInterfaceResetProjectRunnerRegistrationTokenCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResetProjectRunnerRegistrationToken", reflect.TypeOf((*MockRunnersServiceInterface)(nil).ResetProjectRunnerRegistrationToken), varargs...)
	return &MockRunnersServiceInterfaceResetProjectRunnerRegistrationTokenCall{Call: call}
}

// MockRunnersServiceInterfaceResetProjectRunnerRegistrationTokenCall wrap *gomock.Call
type MockRunnersServiceInterfaceResetProjectRunnerRegistrationTokenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnersServiceInterfaceResetProjectRunnerRegistrationTokenCall) Return(arg0 *gitlab.RunnerRegistrationToken, arg1 *gitlab.Response, arg2 error) *MockRunnersServiceInterfaceResetProjectRunnerRegistrationTokenCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnersServiceInterfaceResetProjectRunnerRegistrationTokenCall) Do(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.RunnerRegistrationToken, *gitlab.Response, error)) *MockRunnersServiceInterfaceResetProjectRunnerRegistrationTokenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnersServiceInterfaceResetProjectRunnerRegistrationTokenCall) DoAndReturn(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.RunnerRegistrationToken, *gitlab.Response, error)) *MockRunnersServiceInterfaceResetProjectRunnerRegistrationTokenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ResetRunnerAuthenticationToken mocks base method.
func (m *MockRunnersServiceInterface) ResetRunnerAuthenticationToken(rid int, options ...gitlab.RequestOptionFunc) (*gitlab.RunnerAuthenticationToken, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{rid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ResetRunnerAuthenticationToken", varargs...)
	ret0, _ := ret[0].(*gitlab.RunnerAuthenticationToken)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ResetRunnerAuthenticationToken indicates an expected call of ResetRunnerAuthenticationToken.
func (mr *MockRunnersServiceInterfaceMockRecorder) ResetRunnerAuthenticationToken(rid any, options ...any) *MockRunnersServiceInterfaceResetRunnerAuthenticationTokenCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{rid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResetRunnerAuthenticationToken", reflect.TypeOf((*MockRunnersServiceInterface)(nil).ResetRunnerAuthenticationToken), varargs...)
	return &MockRunnersServiceInterfaceResetRunnerAuthenticationTokenCall{Call: call}
}

// MockRunnersServiceInterfaceResetRunnerAuthenticationTokenCall wrap *gomock.Call
type MockRunnersServiceInterfaceResetRunnerAuthenticationTokenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnersServiceInterfaceResetRunnerAuthenticationTokenCall) Return(arg0 *gitlab.RunnerAuthenticationToken, arg1 *gitlab.Response, arg2 error) *MockRunnersServiceInterfaceResetRunnerAuthenticationTokenCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnersServiceInterfaceResetRunnerAuthenticationTokenCall) Do(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.RunnerAuthenticationToken, *gitlab.Response, error)) *MockRunnersServiceInterfaceResetRunnerAuthenticationTokenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnersServiceInterfaceResetRunnerAuthenticationTokenCall) DoAndReturn(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.RunnerAuthenticationToken, *gitlab.Response, error)) *MockRunnersServiceInterfaceResetRunnerAuthenticationTokenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateRunnerDetails mocks base method.
func (m *MockRunnersServiceInterface) UpdateRunnerDetails(rid any, opt *gitlab.UpdateRunnerDetailsOptions, options ...gitlab.RequestOptionFunc) (*gitlab.RunnerDetails, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{rid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateRunnerDetails", varargs...)
	ret0, _ := ret[0].(*gitlab.RunnerDetails)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// UpdateRunnerDetails indicates an expected call of UpdateRunnerDetails.
func (mr *MockRunnersServiceInterfaceMockRecorder) UpdateRunnerDetails(rid, opt any, options ...any) *MockRunnersServiceInterfaceUpdateRunnerDetailsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{rid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateRunnerDetails", reflect.TypeOf((*MockRunnersServiceInterface)(nil).UpdateRunnerDetails), varargs...)
	return &MockRunnersServiceInterfaceUpdateRunnerDetailsCall{Call: call}
}

// MockRunnersServiceInterfaceUpdateRunnerDetailsCall wrap *gomock.Call
type MockRunnersServiceInterfaceUpdateRunnerDetailsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnersServiceInterfaceUpdateRunnerDetailsCall) Return(arg0 *gitlab.RunnerDetails, arg1 *gitlab.Response, arg2 error) *MockRunnersServiceInterfaceUpdateRunnerDetailsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnersServiceInterfaceUpdateRunnerDetailsCall) Do(f func(any, *gitlab.UpdateRunnerDetailsOptions, ...gitlab.RequestOptionFunc) (*gitlab.RunnerDetails, *gitlab.Response, error)) *MockRunnersServiceInterfaceUpdateRunnerDetailsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnersServiceInterfaceUpdateRunnerDetailsCall) DoAndReturn(f func(any, *gitlab.UpdateRunnerDetailsOptions, ...gitlab.RequestOptionFunc) (*gitlab.RunnerDetails, *gitlab.Response, error)) *MockRunnersServiceInterfaceUpdateRunnerDetailsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VerifyRegisteredRunner mocks base method.
func (m *MockRunnersServiceInterface) VerifyRegisteredRunner(opt *gitlab.VerifyRegisteredRunnerOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "VerifyRegisteredRunner", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// VerifyRegisteredRunner indicates an expected call of VerifyRegisteredRunner.
func (mr *MockRunnersServiceInterfaceMockRecorder) VerifyRegisteredRunner(opt any, options ...any) *MockRunnersServiceInterfaceVerifyRegisteredRunnerCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifyRegisteredRunner", reflect.TypeOf((*MockRunnersServiceInterface)(nil).VerifyRegisteredRunner), varargs...)
	return &MockRunnersServiceInterfaceVerifyRegisteredRunnerCall{Call: call}
}

// MockRunnersServiceInterfaceVerifyRegisteredRunnerCall wrap *gomock.Call
type MockRunnersServiceInterfaceVerifyRegisteredRunnerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRunnersServiceInterfaceVerifyRegisteredRunnerCall) Return(arg0 *gitlab.Response, arg1 error) *MockRunnersServiceInterfaceVerifyRegisteredRunnerCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRunnersServiceInterfaceVerifyRegisteredRunnerCall) Do(f func(*gitlab.VerifyRegisteredRunnerOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockRunnersServiceInterfaceVerifyRegisteredRunnerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRunnersServiceInterfaceVerifyRegisteredRunnerCall) DoAndReturn(f func(*gitlab.VerifyRegisteredRunnerOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockRunnersServiceInterfaceVerifyRegisteredRunnerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
