// Code generated by MockGen. DO NOT EDIT.
// Source: gitlab.com/gitlab-org/api/client-go (interfaces: IssuesServiceInterface)
//
// Generated by this command:
//
//	mockgen -typed -destination=issues_mock.go -write_package_comment=false -package=testing gitlab.com/gitlab-org/api/client-go IssuesServiceInterface
//

package testing

import (
	reflect "reflect"

	gitlab "gitlab.com/gitlab-org/api/client-go"
	gomock "go.uber.org/mock/gomock"
)

// MockIssuesServiceInterface is a mock of IssuesServiceInterface interface.
type MockIssuesServiceInterface struct {
	ctrl     *gomock.Controller
	recorder *MockIssuesServiceInterfaceMockRecorder
	isgomock struct{}
}

// MockIssuesServiceInterfaceMockRecorder is the mock recorder for MockIssuesServiceInterface.
type MockIssuesServiceInterfaceMockRecorder struct {
	mock *MockIssuesServiceInterface
}

// NewMockIssuesServiceInterface creates a new mock instance.
func NewMockIssuesServiceInterface(ctrl *gomock.Controller) *MockIssuesServiceInterface {
	mock := &MockIssuesServiceInterface{ctrl: ctrl}
	mock.recorder = &MockIssuesServiceInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIssuesServiceInterface) EXPECT() *MockIssuesServiceInterfaceMockRecorder {
	return m.recorder
}

// AddSpentTime mocks base method.
func (m *MockIssuesServiceInterface) AddSpentTime(pid any, issue int, opt *gitlab.AddSpentTimeOptions, options ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, issue, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddSpentTime", varargs...)
	ret0, _ := ret[0].(*gitlab.TimeStats)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// AddSpentTime indicates an expected call of AddSpentTime.
func (mr *MockIssuesServiceInterfaceMockRecorder) AddSpentTime(pid, issue, opt any, options ...any) *MockIssuesServiceInterfaceAddSpentTimeCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, issue, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddSpentTime", reflect.TypeOf((*MockIssuesServiceInterface)(nil).AddSpentTime), varargs...)
	return &MockIssuesServiceInterfaceAddSpentTimeCall{Call: call}
}

// MockIssuesServiceInterfaceAddSpentTimeCall wrap *gomock.Call
type MockIssuesServiceInterfaceAddSpentTimeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIssuesServiceInterfaceAddSpentTimeCall) Return(arg0 *gitlab.TimeStats, arg1 *gitlab.Response, arg2 error) *MockIssuesServiceInterfaceAddSpentTimeCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIssuesServiceInterfaceAddSpentTimeCall) Do(f func(any, int, *gitlab.AddSpentTimeOptions, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)) *MockIssuesServiceInterfaceAddSpentTimeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIssuesServiceInterfaceAddSpentTimeCall) DoAndReturn(f func(any, int, *gitlab.AddSpentTimeOptions, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)) *MockIssuesServiceInterfaceAddSpentTimeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateIssue mocks base method.
func (m *MockIssuesServiceInterface) CreateIssue(pid any, opt *gitlab.CreateIssueOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateIssue", varargs...)
	ret0, _ := ret[0].(*gitlab.Issue)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreateIssue indicates an expected call of CreateIssue.
func (mr *MockIssuesServiceInterfaceMockRecorder) CreateIssue(pid, opt any, options ...any) *MockIssuesServiceInterfaceCreateIssueCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateIssue", reflect.TypeOf((*MockIssuesServiceInterface)(nil).CreateIssue), varargs...)
	return &MockIssuesServiceInterfaceCreateIssueCall{Call: call}
}

// MockIssuesServiceInterfaceCreateIssueCall wrap *gomock.Call
type MockIssuesServiceInterfaceCreateIssueCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIssuesServiceInterfaceCreateIssueCall) Return(arg0 *gitlab.Issue, arg1 *gitlab.Response, arg2 error) *MockIssuesServiceInterfaceCreateIssueCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIssuesServiceInterfaceCreateIssueCall) Do(f func(any, *gitlab.CreateIssueOptions, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceCreateIssueCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIssuesServiceInterfaceCreateIssueCall) DoAndReturn(f func(any, *gitlab.CreateIssueOptions, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceCreateIssueCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateTodo mocks base method.
func (m *MockIssuesServiceInterface) CreateTodo(pid any, issue int, options ...gitlab.RequestOptionFunc) (*gitlab.Todo, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, issue}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateTodo", varargs...)
	ret0, _ := ret[0].(*gitlab.Todo)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreateTodo indicates an expected call of CreateTodo.
func (mr *MockIssuesServiceInterfaceMockRecorder) CreateTodo(pid, issue any, options ...any) *MockIssuesServiceInterfaceCreateTodoCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, issue}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTodo", reflect.TypeOf((*MockIssuesServiceInterface)(nil).CreateTodo), varargs...)
	return &MockIssuesServiceInterfaceCreateTodoCall{Call: call}
}

// MockIssuesServiceInterfaceCreateTodoCall wrap *gomock.Call
type MockIssuesServiceInterfaceCreateTodoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIssuesServiceInterfaceCreateTodoCall) Return(arg0 *gitlab.Todo, arg1 *gitlab.Response, arg2 error) *MockIssuesServiceInterfaceCreateTodoCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIssuesServiceInterfaceCreateTodoCall) Do(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.Todo, *gitlab.Response, error)) *MockIssuesServiceInterfaceCreateTodoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIssuesServiceInterfaceCreateTodoCall) DoAndReturn(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.Todo, *gitlab.Response, error)) *MockIssuesServiceInterfaceCreateTodoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteIssue mocks base method.
func (m *MockIssuesServiceInterface) DeleteIssue(pid any, issue int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, issue}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteIssue", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteIssue indicates an expected call of DeleteIssue.
func (mr *MockIssuesServiceInterfaceMockRecorder) DeleteIssue(pid, issue any, options ...any) *MockIssuesServiceInterfaceDeleteIssueCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, issue}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteIssue", reflect.TypeOf((*MockIssuesServiceInterface)(nil).DeleteIssue), varargs...)
	return &MockIssuesServiceInterfaceDeleteIssueCall{Call: call}
}

// MockIssuesServiceInterfaceDeleteIssueCall wrap *gomock.Call
type MockIssuesServiceInterfaceDeleteIssueCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIssuesServiceInterfaceDeleteIssueCall) Return(arg0 *gitlab.Response, arg1 error) *MockIssuesServiceInterfaceDeleteIssueCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIssuesServiceInterfaceDeleteIssueCall) Do(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockIssuesServiceInterfaceDeleteIssueCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIssuesServiceInterfaceDeleteIssueCall) DoAndReturn(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockIssuesServiceInterfaceDeleteIssueCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetIssue mocks base method.
func (m *MockIssuesServiceInterface) GetIssue(pid any, issue int, options ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, issue}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetIssue", varargs...)
	ret0, _ := ret[0].(*gitlab.Issue)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetIssue indicates an expected call of GetIssue.
func (mr *MockIssuesServiceInterfaceMockRecorder) GetIssue(pid, issue any, options ...any) *MockIssuesServiceInterfaceGetIssueCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, issue}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetIssue", reflect.TypeOf((*MockIssuesServiceInterface)(nil).GetIssue), varargs...)
	return &MockIssuesServiceInterfaceGetIssueCall{Call: call}
}

// MockIssuesServiceInterfaceGetIssueCall wrap *gomock.Call
type MockIssuesServiceInterfaceGetIssueCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIssuesServiceInterfaceGetIssueCall) Return(arg0 *gitlab.Issue, arg1 *gitlab.Response, arg2 error) *MockIssuesServiceInterfaceGetIssueCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIssuesServiceInterfaceGetIssueCall) Do(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceGetIssueCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIssuesServiceInterfaceGetIssueCall) DoAndReturn(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceGetIssueCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetIssueByID mocks base method.
func (m *MockIssuesServiceInterface) GetIssueByID(issue int, options ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{issue}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetIssueByID", varargs...)
	ret0, _ := ret[0].(*gitlab.Issue)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetIssueByID indicates an expected call of GetIssueByID.
func (mr *MockIssuesServiceInterfaceMockRecorder) GetIssueByID(issue any, options ...any) *MockIssuesServiceInterfaceGetIssueByIDCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{issue}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetIssueByID", reflect.TypeOf((*MockIssuesServiceInterface)(nil).GetIssueByID), varargs...)
	return &MockIssuesServiceInterfaceGetIssueByIDCall{Call: call}
}

// MockIssuesServiceInterfaceGetIssueByIDCall wrap *gomock.Call
type MockIssuesServiceInterfaceGetIssueByIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIssuesServiceInterfaceGetIssueByIDCall) Return(arg0 *gitlab.Issue, arg1 *gitlab.Response, arg2 error) *MockIssuesServiceInterfaceGetIssueByIDCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIssuesServiceInterfaceGetIssueByIDCall) Do(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceGetIssueByIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIssuesServiceInterfaceGetIssueByIDCall) DoAndReturn(f func(int, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceGetIssueByIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetParticipants mocks base method.
func (m *MockIssuesServiceInterface) GetParticipants(pid any, issue int, options ...gitlab.RequestOptionFunc) ([]*gitlab.BasicUser, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, issue}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetParticipants", varargs...)
	ret0, _ := ret[0].([]*gitlab.BasicUser)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetParticipants indicates an expected call of GetParticipants.
func (mr *MockIssuesServiceInterfaceMockRecorder) GetParticipants(pid, issue any, options ...any) *MockIssuesServiceInterfaceGetParticipantsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, issue}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetParticipants", reflect.TypeOf((*MockIssuesServiceInterface)(nil).GetParticipants), varargs...)
	return &MockIssuesServiceInterfaceGetParticipantsCall{Call: call}
}

// MockIssuesServiceInterfaceGetParticipantsCall wrap *gomock.Call
type MockIssuesServiceInterfaceGetParticipantsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIssuesServiceInterfaceGetParticipantsCall) Return(arg0 []*gitlab.BasicUser, arg1 *gitlab.Response, arg2 error) *MockIssuesServiceInterfaceGetParticipantsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIssuesServiceInterfaceGetParticipantsCall) Do(f func(any, int, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicUser, *gitlab.Response, error)) *MockIssuesServiceInterfaceGetParticipantsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIssuesServiceInterfaceGetParticipantsCall) DoAndReturn(f func(any, int, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicUser, *gitlab.Response, error)) *MockIssuesServiceInterfaceGetParticipantsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTimeSpent mocks base method.
func (m *MockIssuesServiceInterface) GetTimeSpent(pid any, issue int, options ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, issue}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetTimeSpent", varargs...)
	ret0, _ := ret[0].(*gitlab.TimeStats)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetTimeSpent indicates an expected call of GetTimeSpent.
func (mr *MockIssuesServiceInterfaceMockRecorder) GetTimeSpent(pid, issue any, options ...any) *MockIssuesServiceInterfaceGetTimeSpentCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, issue}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTimeSpent", reflect.TypeOf((*MockIssuesServiceInterface)(nil).GetTimeSpent), varargs...)
	return &MockIssuesServiceInterfaceGetTimeSpentCall{Call: call}
}

// MockIssuesServiceInterfaceGetTimeSpentCall wrap *gomock.Call
type MockIssuesServiceInterfaceGetTimeSpentCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIssuesServiceInterfaceGetTimeSpentCall) Return(arg0 *gitlab.TimeStats, arg1 *gitlab.Response, arg2 error) *MockIssuesServiceInterfaceGetTimeSpentCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIssuesServiceInterfaceGetTimeSpentCall) Do(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)) *MockIssuesServiceInterfaceGetTimeSpentCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIssuesServiceInterfaceGetTimeSpentCall) DoAndReturn(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)) *MockIssuesServiceInterfaceGetTimeSpentCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListGroupIssues mocks base method.
func (m *MockIssuesServiceInterface) ListGroupIssues(pid any, opt *gitlab.ListGroupIssuesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListGroupIssues", varargs...)
	ret0, _ := ret[0].([]*gitlab.Issue)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListGroupIssues indicates an expected call of ListGroupIssues.
func (mr *MockIssuesServiceInterfaceMockRecorder) ListGroupIssues(pid, opt any, options ...any) *MockIssuesServiceInterfaceListGroupIssuesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListGroupIssues", reflect.TypeOf((*MockIssuesServiceInterface)(nil).ListGroupIssues), varargs...)
	return &MockIssuesServiceInterfaceListGroupIssuesCall{Call: call}
}

// MockIssuesServiceInterfaceListGroupIssuesCall wrap *gomock.Call
type MockIssuesServiceInterfaceListGroupIssuesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIssuesServiceInterfaceListGroupIssuesCall) Return(arg0 []*gitlab.Issue, arg1 *gitlab.Response, arg2 error) *MockIssuesServiceInterfaceListGroupIssuesCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIssuesServiceInterfaceListGroupIssuesCall) Do(f func(any, *gitlab.ListGroupIssuesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceListGroupIssuesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIssuesServiceInterfaceListGroupIssuesCall) DoAndReturn(f func(any, *gitlab.ListGroupIssuesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceListGroupIssuesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListIssues mocks base method.
func (m *MockIssuesServiceInterface) ListIssues(opt *gitlab.ListIssuesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListIssues", varargs...)
	ret0, _ := ret[0].([]*gitlab.Issue)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListIssues indicates an expected call of ListIssues.
func (mr *MockIssuesServiceInterfaceMockRecorder) ListIssues(opt any, options ...any) *MockIssuesServiceInterfaceListIssuesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListIssues", reflect.TypeOf((*MockIssuesServiceInterface)(nil).ListIssues), varargs...)
	return &MockIssuesServiceInterfaceListIssuesCall{Call: call}
}

// MockIssuesServiceInterfaceListIssuesCall wrap *gomock.Call
type MockIssuesServiceInterfaceListIssuesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIssuesServiceInterfaceListIssuesCall) Return(arg0 []*gitlab.Issue, arg1 *gitlab.Response, arg2 error) *MockIssuesServiceInterfaceListIssuesCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIssuesServiceInterfaceListIssuesCall) Do(f func(*gitlab.ListIssuesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceListIssuesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIssuesServiceInterfaceListIssuesCall) DoAndReturn(f func(*gitlab.ListIssuesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceListIssuesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListMergeRequestsClosingIssue mocks base method.
func (m *MockIssuesServiceInterface) ListMergeRequestsClosingIssue(pid any, issue int, opt *gitlab.ListMergeRequestsClosingIssueOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, issue, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListMergeRequestsClosingIssue", varargs...)
	ret0, _ := ret[0].([]*gitlab.BasicMergeRequest)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListMergeRequestsClosingIssue indicates an expected call of ListMergeRequestsClosingIssue.
func (mr *MockIssuesServiceInterfaceMockRecorder) ListMergeRequestsClosingIssue(pid, issue, opt any, options ...any) *MockIssuesServiceInterfaceListMergeRequestsClosingIssueCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, issue, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListMergeRequestsClosingIssue", reflect.TypeOf((*MockIssuesServiceInterface)(nil).ListMergeRequestsClosingIssue), varargs...)
	return &MockIssuesServiceInterfaceListMergeRequestsClosingIssueCall{Call: call}
}

// MockIssuesServiceInterfaceListMergeRequestsClosingIssueCall wrap *gomock.Call
type MockIssuesServiceInterfaceListMergeRequestsClosingIssueCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIssuesServiceInterfaceListMergeRequestsClosingIssueCall) Return(arg0 []*gitlab.BasicMergeRequest, arg1 *gitlab.Response, arg2 error) *MockIssuesServiceInterfaceListMergeRequestsClosingIssueCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIssuesServiceInterfaceListMergeRequestsClosingIssueCall) Do(f func(any, int, *gitlab.ListMergeRequestsClosingIssueOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error)) *MockIssuesServiceInterfaceListMergeRequestsClosingIssueCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIssuesServiceInterfaceListMergeRequestsClosingIssueCall) DoAndReturn(f func(any, int, *gitlab.ListMergeRequestsClosingIssueOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error)) *MockIssuesServiceInterfaceListMergeRequestsClosingIssueCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListMergeRequestsRelatedToIssue mocks base method.
func (m *MockIssuesServiceInterface) ListMergeRequestsRelatedToIssue(pid any, issue int, opt *gitlab.ListMergeRequestsRelatedToIssueOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, issue, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListMergeRequestsRelatedToIssue", varargs...)
	ret0, _ := ret[0].([]*gitlab.BasicMergeRequest)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListMergeRequestsRelatedToIssue indicates an expected call of ListMergeRequestsRelatedToIssue.
func (mr *MockIssuesServiceInterfaceMockRecorder) ListMergeRequestsRelatedToIssue(pid, issue, opt any, options ...any) *MockIssuesServiceInterfaceListMergeRequestsRelatedToIssueCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, issue, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListMergeRequestsRelatedToIssue", reflect.TypeOf((*MockIssuesServiceInterface)(nil).ListMergeRequestsRelatedToIssue), varargs...)
	return &MockIssuesServiceInterfaceListMergeRequestsRelatedToIssueCall{Call: call}
}

// MockIssuesServiceInterfaceListMergeRequestsRelatedToIssueCall wrap *gomock.Call
type MockIssuesServiceInterfaceListMergeRequestsRelatedToIssueCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIssuesServiceInterfaceListMergeRequestsRelatedToIssueCall) Return(arg0 []*gitlab.BasicMergeRequest, arg1 *gitlab.Response, arg2 error) *MockIssuesServiceInterfaceListMergeRequestsRelatedToIssueCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIssuesServiceInterfaceListMergeRequestsRelatedToIssueCall) Do(f func(any, int, *gitlab.ListMergeRequestsRelatedToIssueOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error)) *MockIssuesServiceInterfaceListMergeRequestsRelatedToIssueCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIssuesServiceInterfaceListMergeRequestsRelatedToIssueCall) DoAndReturn(f func(any, int, *gitlab.ListMergeRequestsRelatedToIssueOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error)) *MockIssuesServiceInterfaceListMergeRequestsRelatedToIssueCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListProjectIssues mocks base method.
func (m *MockIssuesServiceInterface) ListProjectIssues(pid any, opt *gitlab.ListProjectIssuesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListProjectIssues", varargs...)
	ret0, _ := ret[0].([]*gitlab.Issue)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListProjectIssues indicates an expected call of ListProjectIssues.
func (mr *MockIssuesServiceInterfaceMockRecorder) ListProjectIssues(pid, opt any, options ...any) *MockIssuesServiceInterfaceListProjectIssuesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListProjectIssues", reflect.TypeOf((*MockIssuesServiceInterface)(nil).ListProjectIssues), varargs...)
	return &MockIssuesServiceInterfaceListProjectIssuesCall{Call: call}
}

// MockIssuesServiceInterfaceListProjectIssuesCall wrap *gomock.Call
type MockIssuesServiceInterfaceListProjectIssuesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIssuesServiceInterfaceListProjectIssuesCall) Return(arg0 []*gitlab.Issue, arg1 *gitlab.Response, arg2 error) *MockIssuesServiceInterfaceListProjectIssuesCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIssuesServiceInterfaceListProjectIssuesCall) Do(f func(any, *gitlab.ListProjectIssuesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceListProjectIssuesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIssuesServiceInterfaceListProjectIssuesCall) DoAndReturn(f func(any, *gitlab.ListProjectIssuesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceListProjectIssuesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MoveIssue mocks base method.
func (m *MockIssuesServiceInterface) MoveIssue(pid any, issue int, opt *gitlab.MoveIssueOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, issue, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MoveIssue", varargs...)
	ret0, _ := ret[0].(*gitlab.Issue)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MoveIssue indicates an expected call of MoveIssue.
func (mr *MockIssuesServiceInterfaceMockRecorder) MoveIssue(pid, issue, opt any, options ...any) *MockIssuesServiceInterfaceMoveIssueCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, issue, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MoveIssue", reflect.TypeOf((*MockIssuesServiceInterface)(nil).MoveIssue), varargs...)
	return &MockIssuesServiceInterfaceMoveIssueCall{Call: call}
}

// MockIssuesServiceInterfaceMoveIssueCall wrap *gomock.Call
type MockIssuesServiceInterfaceMoveIssueCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIssuesServiceInterfaceMoveIssueCall) Return(arg0 *gitlab.Issue, arg1 *gitlab.Response, arg2 error) *MockIssuesServiceInterfaceMoveIssueCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIssuesServiceInterfaceMoveIssueCall) Do(f func(any, int, *gitlab.MoveIssueOptions, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceMoveIssueCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIssuesServiceInterfaceMoveIssueCall) DoAndReturn(f func(any, int, *gitlab.MoveIssueOptions, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceMoveIssueCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReorderIssue mocks base method.
func (m *MockIssuesServiceInterface) ReorderIssue(pid any, issue int, opt *gitlab.ReorderIssueOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, issue, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReorderIssue", varargs...)
	ret0, _ := ret[0].(*gitlab.Issue)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ReorderIssue indicates an expected call of ReorderIssue.
func (mr *MockIssuesServiceInterfaceMockRecorder) ReorderIssue(pid, issue, opt any, options ...any) *MockIssuesServiceInterfaceReorderIssueCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, issue, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReorderIssue", reflect.TypeOf((*MockIssuesServiceInterface)(nil).ReorderIssue), varargs...)
	return &MockIssuesServiceInterfaceReorderIssueCall{Call: call}
}

// MockIssuesServiceInterfaceReorderIssueCall wrap *gomock.Call
type MockIssuesServiceInterfaceReorderIssueCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIssuesServiceInterfaceReorderIssueCall) Return(arg0 *gitlab.Issue, arg1 *gitlab.Response, arg2 error) *MockIssuesServiceInterfaceReorderIssueCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIssuesServiceInterfaceReorderIssueCall) Do(f func(any, int, *gitlab.ReorderIssueOptions, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceReorderIssueCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIssuesServiceInterfaceReorderIssueCall) DoAndReturn(f func(any, int, *gitlab.ReorderIssueOptions, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceReorderIssueCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ResetSpentTime mocks base method.
func (m *MockIssuesServiceInterface) ResetSpentTime(pid any, issue int, options ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, issue}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ResetSpentTime", varargs...)
	ret0, _ := ret[0].(*gitlab.TimeStats)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ResetSpentTime indicates an expected call of ResetSpentTime.
func (mr *MockIssuesServiceInterfaceMockRecorder) ResetSpentTime(pid, issue any, options ...any) *MockIssuesServiceInterfaceResetSpentTimeCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, issue}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResetSpentTime", reflect.TypeOf((*MockIssuesServiceInterface)(nil).ResetSpentTime), varargs...)
	return &MockIssuesServiceInterfaceResetSpentTimeCall{Call: call}
}

// MockIssuesServiceInterfaceResetSpentTimeCall wrap *gomock.Call
type MockIssuesServiceInterfaceResetSpentTimeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIssuesServiceInterfaceResetSpentTimeCall) Return(arg0 *gitlab.TimeStats, arg1 *gitlab.Response, arg2 error) *MockIssuesServiceInterfaceResetSpentTimeCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIssuesServiceInterfaceResetSpentTimeCall) Do(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)) *MockIssuesServiceInterfaceResetSpentTimeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIssuesServiceInterfaceResetSpentTimeCall) DoAndReturn(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)) *MockIssuesServiceInterfaceResetSpentTimeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ResetTimeEstimate mocks base method.
func (m *MockIssuesServiceInterface) ResetTimeEstimate(pid any, issue int, options ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, issue}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ResetTimeEstimate", varargs...)
	ret0, _ := ret[0].(*gitlab.TimeStats)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ResetTimeEstimate indicates an expected call of ResetTimeEstimate.
func (mr *MockIssuesServiceInterfaceMockRecorder) ResetTimeEstimate(pid, issue any, options ...any) *MockIssuesServiceInterfaceResetTimeEstimateCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, issue}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResetTimeEstimate", reflect.TypeOf((*MockIssuesServiceInterface)(nil).ResetTimeEstimate), varargs...)
	return &MockIssuesServiceInterfaceResetTimeEstimateCall{Call: call}
}

// MockIssuesServiceInterfaceResetTimeEstimateCall wrap *gomock.Call
type MockIssuesServiceInterfaceResetTimeEstimateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIssuesServiceInterfaceResetTimeEstimateCall) Return(arg0 *gitlab.TimeStats, arg1 *gitlab.Response, arg2 error) *MockIssuesServiceInterfaceResetTimeEstimateCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIssuesServiceInterfaceResetTimeEstimateCall) Do(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)) *MockIssuesServiceInterfaceResetTimeEstimateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIssuesServiceInterfaceResetTimeEstimateCall) DoAndReturn(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)) *MockIssuesServiceInterfaceResetTimeEstimateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetTimeEstimate mocks base method.
func (m *MockIssuesServiceInterface) SetTimeEstimate(pid any, issue int, opt *gitlab.SetTimeEstimateOptions, options ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, issue, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SetTimeEstimate", varargs...)
	ret0, _ := ret[0].(*gitlab.TimeStats)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// SetTimeEstimate indicates an expected call of SetTimeEstimate.
func (mr *MockIssuesServiceInterfaceMockRecorder) SetTimeEstimate(pid, issue, opt any, options ...any) *MockIssuesServiceInterfaceSetTimeEstimateCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, issue, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetTimeEstimate", reflect.TypeOf((*MockIssuesServiceInterface)(nil).SetTimeEstimate), varargs...)
	return &MockIssuesServiceInterfaceSetTimeEstimateCall{Call: call}
}

// MockIssuesServiceInterfaceSetTimeEstimateCall wrap *gomock.Call
type MockIssuesServiceInterfaceSetTimeEstimateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIssuesServiceInterfaceSetTimeEstimateCall) Return(arg0 *gitlab.TimeStats, arg1 *gitlab.Response, arg2 error) *MockIssuesServiceInterfaceSetTimeEstimateCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIssuesServiceInterfaceSetTimeEstimateCall) Do(f func(any, int, *gitlab.SetTimeEstimateOptions, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)) *MockIssuesServiceInterfaceSetTimeEstimateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIssuesServiceInterfaceSetTimeEstimateCall) DoAndReturn(f func(any, int, *gitlab.SetTimeEstimateOptions, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)) *MockIssuesServiceInterfaceSetTimeEstimateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SubscribeToIssue mocks base method.
func (m *MockIssuesServiceInterface) SubscribeToIssue(pid any, issue int, options ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, issue}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubscribeToIssue", varargs...)
	ret0, _ := ret[0].(*gitlab.Issue)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// SubscribeToIssue indicates an expected call of SubscribeToIssue.
func (mr *MockIssuesServiceInterfaceMockRecorder) SubscribeToIssue(pid, issue any, options ...any) *MockIssuesServiceInterfaceSubscribeToIssueCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, issue}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribeToIssue", reflect.TypeOf((*MockIssuesServiceInterface)(nil).SubscribeToIssue), varargs...)
	return &MockIssuesServiceInterfaceSubscribeToIssueCall{Call: call}
}

// MockIssuesServiceInterfaceSubscribeToIssueCall wrap *gomock.Call
type MockIssuesServiceInterfaceSubscribeToIssueCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIssuesServiceInterfaceSubscribeToIssueCall) Return(arg0 *gitlab.Issue, arg1 *gitlab.Response, arg2 error) *MockIssuesServiceInterfaceSubscribeToIssueCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIssuesServiceInterfaceSubscribeToIssueCall) Do(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceSubscribeToIssueCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIssuesServiceInterfaceSubscribeToIssueCall) DoAndReturn(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceSubscribeToIssueCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnsubscribeFromIssue mocks base method.
func (m *MockIssuesServiceInterface) UnsubscribeFromIssue(pid any, issue int, options ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, issue}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UnsubscribeFromIssue", varargs...)
	ret0, _ := ret[0].(*gitlab.Issue)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// UnsubscribeFromIssue indicates an expected call of UnsubscribeFromIssue.
func (mr *MockIssuesServiceInterfaceMockRecorder) UnsubscribeFromIssue(pid, issue any, options ...any) *MockIssuesServiceInterfaceUnsubscribeFromIssueCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, issue}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnsubscribeFromIssue", reflect.TypeOf((*MockIssuesServiceInterface)(nil).UnsubscribeFromIssue), varargs...)
	return &MockIssuesServiceInterfaceUnsubscribeFromIssueCall{Call: call}
}

// MockIssuesServiceInterfaceUnsubscribeFromIssueCall wrap *gomock.Call
type MockIssuesServiceInterfaceUnsubscribeFromIssueCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIssuesServiceInterfaceUnsubscribeFromIssueCall) Return(arg0 *gitlab.Issue, arg1 *gitlab.Response, arg2 error) *MockIssuesServiceInterfaceUnsubscribeFromIssueCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIssuesServiceInterfaceUnsubscribeFromIssueCall) Do(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceUnsubscribeFromIssueCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIssuesServiceInterfaceUnsubscribeFromIssueCall) DoAndReturn(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceUnsubscribeFromIssueCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateIssue mocks base method.
func (m *MockIssuesServiceInterface) UpdateIssue(pid any, issue int, opt *gitlab.UpdateIssueOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, issue, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateIssue", varargs...)
	ret0, _ := ret[0].(*gitlab.Issue)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// UpdateIssue indicates an expected call of UpdateIssue.
func (mr *MockIssuesServiceInterfaceMockRecorder) UpdateIssue(pid, issue, opt any, options ...any) *MockIssuesServiceInterfaceUpdateIssueCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, issue, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateIssue", reflect.TypeOf((*MockIssuesServiceInterface)(nil).UpdateIssue), varargs...)
	return &MockIssuesServiceInterfaceUpdateIssueCall{Call: call}
}

// MockIssuesServiceInterfaceUpdateIssueCall wrap *gomock.Call
type MockIssuesServiceInterfaceUpdateIssueCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIssuesServiceInterfaceUpdateIssueCall) Return(arg0 *gitlab.Issue, arg1 *gitlab.Response, arg2 error) *MockIssuesServiceInterfaceUpdateIssueCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIssuesServiceInterfaceUpdateIssueCall) Do(f func(any, int, *gitlab.UpdateIssueOptions, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceUpdateIssueCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIssuesServiceInterfaceUpdateIssueCall) DoAndReturn(f func(any, int, *gitlab.UpdateIssueOptions, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *MockIssuesServiceInterfaceUpdateIssueCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
