// Code generated by MockGen. DO NOT EDIT.
// Source: gitlab.com/gitlab-org/api/client-go (interfaces: NotesServiceInterface)
//
// Generated by this command:
//
//	mockgen -typed -destination=notes_mock.go -write_package_comment=false -package=testing gitlab.com/gitlab-org/api/client-go NotesServiceInterface
//

package testing

import (
	reflect "reflect"

	gitlab "gitlab.com/gitlab-org/api/client-go"
	gomock "go.uber.org/mock/gomock"
)

// MockNotesServiceInterface is a mock of NotesServiceInterface interface.
type MockNotesServiceInterface struct {
	ctrl     *gomock.Controller
	recorder *MockNotesServiceInterfaceMockRecorder
	isgomock struct{}
}

// MockNotesServiceInterfaceMockRecorder is the mock recorder for MockNotesServiceInterface.
type MockNotesServiceInterfaceMockRecorder struct {
	mock *MockNotesServiceInterface
}

// NewMockNotesServiceInterface creates a new mock instance.
func NewMockNotesServiceInterface(ctrl *gomock.Controller) *MockNotesServiceInterface {
	mock := &MockNotesServiceInterface{ctrl: ctrl}
	mock.recorder = &MockNotesServiceInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNotesServiceInterface) EXPECT() *MockNotesServiceInterfaceMockRecorder {
	return m.recorder
}

// CreateEpicNote mocks base method.
func (m *MockNotesServiceInterface) CreateEpicNote(gid any, epic int, opt *gitlab.CreateEpicNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{gid, epic, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateEpicNote", varargs...)
	ret0, _ := ret[0].(*gitlab.Note)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreateEpicNote indicates an expected call of CreateEpicNote.
func (mr *MockNotesServiceInterfaceMockRecorder) CreateEpicNote(gid, epic, opt any, options ...any) *MockNotesServiceInterfaceCreateEpicNoteCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{gid, epic, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateEpicNote", reflect.TypeOf((*MockNotesServiceInterface)(nil).CreateEpicNote), varargs...)
	return &MockNotesServiceInterfaceCreateEpicNoteCall{Call: call}
}

// MockNotesServiceInterfaceCreateEpicNoteCall wrap *gomock.Call
type MockNotesServiceInterfaceCreateEpicNoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNotesServiceInterfaceCreateEpicNoteCall) Return(arg0 *gitlab.Note, arg1 *gitlab.Response, arg2 error) *MockNotesServiceInterfaceCreateEpicNoteCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNotesServiceInterfaceCreateEpicNoteCall) Do(f func(any, int, *gitlab.CreateEpicNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceCreateEpicNoteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNotesServiceInterfaceCreateEpicNoteCall) DoAndReturn(f func(any, int, *gitlab.CreateEpicNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceCreateEpicNoteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateIssueNote mocks base method.
func (m *MockNotesServiceInterface) CreateIssueNote(pid any, issue int, opt *gitlab.CreateIssueNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, issue, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateIssueNote", varargs...)
	ret0, _ := ret[0].(*gitlab.Note)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreateIssueNote indicates an expected call of CreateIssueNote.
func (mr *MockNotesServiceInterfaceMockRecorder) CreateIssueNote(pid, issue, opt any, options ...any) *MockNotesServiceInterfaceCreateIssueNoteCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, issue, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateIssueNote", reflect.TypeOf((*MockNotesServiceInterface)(nil).CreateIssueNote), varargs...)
	return &MockNotesServiceInterfaceCreateIssueNoteCall{Call: call}
}

// MockNotesServiceInterfaceCreateIssueNoteCall wrap *gomock.Call
type MockNotesServiceInterfaceCreateIssueNoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNotesServiceInterfaceCreateIssueNoteCall) Return(arg0 *gitlab.Note, arg1 *gitlab.Response, arg2 error) *MockNotesServiceInterfaceCreateIssueNoteCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNotesServiceInterfaceCreateIssueNoteCall) Do(f func(any, int, *gitlab.CreateIssueNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceCreateIssueNoteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNotesServiceInterfaceCreateIssueNoteCall) DoAndReturn(f func(any, int, *gitlab.CreateIssueNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceCreateIssueNoteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateMergeRequestNote mocks base method.
func (m *MockNotesServiceInterface) CreateMergeRequestNote(pid any, mergeRequest int, opt *gitlab.CreateMergeRequestNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, mergeRequest, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateMergeRequestNote", varargs...)
	ret0, _ := ret[0].(*gitlab.Note)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreateMergeRequestNote indicates an expected call of CreateMergeRequestNote.
func (mr *MockNotesServiceInterfaceMockRecorder) CreateMergeRequestNote(pid, mergeRequest, opt any, options ...any) *MockNotesServiceInterfaceCreateMergeRequestNoteCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, mergeRequest, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateMergeRequestNote", reflect.TypeOf((*MockNotesServiceInterface)(nil).CreateMergeRequestNote), varargs...)
	return &MockNotesServiceInterfaceCreateMergeRequestNoteCall{Call: call}
}

// MockNotesServiceInterfaceCreateMergeRequestNoteCall wrap *gomock.Call
type MockNotesServiceInterfaceCreateMergeRequestNoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNotesServiceInterfaceCreateMergeRequestNoteCall) Return(arg0 *gitlab.Note, arg1 *gitlab.Response, arg2 error) *MockNotesServiceInterfaceCreateMergeRequestNoteCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNotesServiceInterfaceCreateMergeRequestNoteCall) Do(f func(any, int, *gitlab.CreateMergeRequestNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceCreateMergeRequestNoteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNotesServiceInterfaceCreateMergeRequestNoteCall) DoAndReturn(f func(any, int, *gitlab.CreateMergeRequestNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceCreateMergeRequestNoteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateSnippetNote mocks base method.
func (m *MockNotesServiceInterface) CreateSnippetNote(pid any, snippet int, opt *gitlab.CreateSnippetNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, snippet, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateSnippetNote", varargs...)
	ret0, _ := ret[0].(*gitlab.Note)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreateSnippetNote indicates an expected call of CreateSnippetNote.
func (mr *MockNotesServiceInterfaceMockRecorder) CreateSnippetNote(pid, snippet, opt any, options ...any) *MockNotesServiceInterfaceCreateSnippetNoteCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, snippet, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateSnippetNote", reflect.TypeOf((*MockNotesServiceInterface)(nil).CreateSnippetNote), varargs...)
	return &MockNotesServiceInterfaceCreateSnippetNoteCall{Call: call}
}

// MockNotesServiceInterfaceCreateSnippetNoteCall wrap *gomock.Call
type MockNotesServiceInterfaceCreateSnippetNoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNotesServiceInterfaceCreateSnippetNoteCall) Return(arg0 *gitlab.Note, arg1 *gitlab.Response, arg2 error) *MockNotesServiceInterfaceCreateSnippetNoteCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNotesServiceInterfaceCreateSnippetNoteCall) Do(f func(any, int, *gitlab.CreateSnippetNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceCreateSnippetNoteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNotesServiceInterfaceCreateSnippetNoteCall) DoAndReturn(f func(any, int, *gitlab.CreateSnippetNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceCreateSnippetNoteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteEpicNote mocks base method.
func (m *MockNotesServiceInterface) DeleteEpicNote(gid any, epic, note int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{gid, epic, note}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteEpicNote", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteEpicNote indicates an expected call of DeleteEpicNote.
func (mr *MockNotesServiceInterfaceMockRecorder) DeleteEpicNote(gid, epic, note any, options ...any) *MockNotesServiceInterfaceDeleteEpicNoteCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{gid, epic, note}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteEpicNote", reflect.TypeOf((*MockNotesServiceInterface)(nil).DeleteEpicNote), varargs...)
	return &MockNotesServiceInterfaceDeleteEpicNoteCall{Call: call}
}

// MockNotesServiceInterfaceDeleteEpicNoteCall wrap *gomock.Call
type MockNotesServiceInterfaceDeleteEpicNoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNotesServiceInterfaceDeleteEpicNoteCall) Return(arg0 *gitlab.Response, arg1 error) *MockNotesServiceInterfaceDeleteEpicNoteCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNotesServiceInterfaceDeleteEpicNoteCall) Do(f func(any, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockNotesServiceInterfaceDeleteEpicNoteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNotesServiceInterfaceDeleteEpicNoteCall) DoAndReturn(f func(any, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockNotesServiceInterfaceDeleteEpicNoteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteIssueNote mocks base method.
func (m *MockNotesServiceInterface) DeleteIssueNote(pid any, issue, note int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, issue, note}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteIssueNote", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteIssueNote indicates an expected call of DeleteIssueNote.
func (mr *MockNotesServiceInterfaceMockRecorder) DeleteIssueNote(pid, issue, note any, options ...any) *MockNotesServiceInterfaceDeleteIssueNoteCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, issue, note}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteIssueNote", reflect.TypeOf((*MockNotesServiceInterface)(nil).DeleteIssueNote), varargs...)
	return &MockNotesServiceInterfaceDeleteIssueNoteCall{Call: call}
}

// MockNotesServiceInterfaceDeleteIssueNoteCall wrap *gomock.Call
type MockNotesServiceInterfaceDeleteIssueNoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNotesServiceInterfaceDeleteIssueNoteCall) Return(arg0 *gitlab.Response, arg1 error) *MockNotesServiceInterfaceDeleteIssueNoteCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNotesServiceInterfaceDeleteIssueNoteCall) Do(f func(any, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockNotesServiceInterfaceDeleteIssueNoteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNotesServiceInterfaceDeleteIssueNoteCall) DoAndReturn(f func(any, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockNotesServiceInterfaceDeleteIssueNoteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteMergeRequestNote mocks base method.
func (m *MockNotesServiceInterface) DeleteMergeRequestNote(pid any, mergeRequest, note int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, mergeRequest, note}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteMergeRequestNote", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteMergeRequestNote indicates an expected call of DeleteMergeRequestNote.
func (mr *MockNotesServiceInterfaceMockRecorder) DeleteMergeRequestNote(pid, mergeRequest, note any, options ...any) *MockNotesServiceInterfaceDeleteMergeRequestNoteCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, mergeRequest, note}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteMergeRequestNote", reflect.TypeOf((*MockNotesServiceInterface)(nil).DeleteMergeRequestNote), varargs...)
	return &MockNotesServiceInterfaceDeleteMergeRequestNoteCall{Call: call}
}

// MockNotesServiceInterfaceDeleteMergeRequestNoteCall wrap *gomock.Call
type MockNotesServiceInterfaceDeleteMergeRequestNoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNotesServiceInterfaceDeleteMergeRequestNoteCall) Return(arg0 *gitlab.Response, arg1 error) *MockNotesServiceInterfaceDeleteMergeRequestNoteCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNotesServiceInterfaceDeleteMergeRequestNoteCall) Do(f func(any, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockNotesServiceInterfaceDeleteMergeRequestNoteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNotesServiceInterfaceDeleteMergeRequestNoteCall) DoAndReturn(f func(any, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockNotesServiceInterfaceDeleteMergeRequestNoteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteSnippetNote mocks base method.
func (m *MockNotesServiceInterface) DeleteSnippetNote(pid any, snippet, note int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, snippet, note}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteSnippetNote", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteSnippetNote indicates an expected call of DeleteSnippetNote.
func (mr *MockNotesServiceInterfaceMockRecorder) DeleteSnippetNote(pid, snippet, note any, options ...any) *MockNotesServiceInterfaceDeleteSnippetNoteCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, snippet, note}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSnippetNote", reflect.TypeOf((*MockNotesServiceInterface)(nil).DeleteSnippetNote), varargs...)
	return &MockNotesServiceInterfaceDeleteSnippetNoteCall{Call: call}
}

// MockNotesServiceInterfaceDeleteSnippetNoteCall wrap *gomock.Call
type MockNotesServiceInterfaceDeleteSnippetNoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNotesServiceInterfaceDeleteSnippetNoteCall) Return(arg0 *gitlab.Response, arg1 error) *MockNotesServiceInterfaceDeleteSnippetNoteCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNotesServiceInterfaceDeleteSnippetNoteCall) Do(f func(any, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockNotesServiceInterfaceDeleteSnippetNoteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNotesServiceInterfaceDeleteSnippetNoteCall) DoAndReturn(f func(any, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockNotesServiceInterfaceDeleteSnippetNoteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetEpicNote mocks base method.
func (m *MockNotesServiceInterface) GetEpicNote(gid any, epic, note int, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{gid, epic, note}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetEpicNote", varargs...)
	ret0, _ := ret[0].(*gitlab.Note)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetEpicNote indicates an expected call of GetEpicNote.
func (mr *MockNotesServiceInterfaceMockRecorder) GetEpicNote(gid, epic, note any, options ...any) *MockNotesServiceInterfaceGetEpicNoteCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{gid, epic, note}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEpicNote", reflect.TypeOf((*MockNotesServiceInterface)(nil).GetEpicNote), varargs...)
	return &MockNotesServiceInterfaceGetEpicNoteCall{Call: call}
}

// MockNotesServiceInterfaceGetEpicNoteCall wrap *gomock.Call
type MockNotesServiceInterfaceGetEpicNoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNotesServiceInterfaceGetEpicNoteCall) Return(arg0 *gitlab.Note, arg1 *gitlab.Response, arg2 error) *MockNotesServiceInterfaceGetEpicNoteCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNotesServiceInterfaceGetEpicNoteCall) Do(f func(any, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceGetEpicNoteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNotesServiceInterfaceGetEpicNoteCall) DoAndReturn(f func(any, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceGetEpicNoteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetIssueNote mocks base method.
func (m *MockNotesServiceInterface) GetIssueNote(pid any, issue, note int, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, issue, note}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetIssueNote", varargs...)
	ret0, _ := ret[0].(*gitlab.Note)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetIssueNote indicates an expected call of GetIssueNote.
func (mr *MockNotesServiceInterfaceMockRecorder) GetIssueNote(pid, issue, note any, options ...any) *MockNotesServiceInterfaceGetIssueNoteCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, issue, note}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetIssueNote", reflect.TypeOf((*MockNotesServiceInterface)(nil).GetIssueNote), varargs...)
	return &MockNotesServiceInterfaceGetIssueNoteCall{Call: call}
}

// MockNotesServiceInterfaceGetIssueNoteCall wrap *gomock.Call
type MockNotesServiceInterfaceGetIssueNoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNotesServiceInterfaceGetIssueNoteCall) Return(arg0 *gitlab.Note, arg1 *gitlab.Response, arg2 error) *MockNotesServiceInterfaceGetIssueNoteCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNotesServiceInterfaceGetIssueNoteCall) Do(f func(any, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceGetIssueNoteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNotesServiceInterfaceGetIssueNoteCall) DoAndReturn(f func(any, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceGetIssueNoteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetMergeRequestNote mocks base method.
func (m *MockNotesServiceInterface) GetMergeRequestNote(pid any, mergeRequest, note int, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, mergeRequest, note}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetMergeRequestNote", varargs...)
	ret0, _ := ret[0].(*gitlab.Note)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetMergeRequestNote indicates an expected call of GetMergeRequestNote.
func (mr *MockNotesServiceInterfaceMockRecorder) GetMergeRequestNote(pid, mergeRequest, note any, options ...any) *MockNotesServiceInterfaceGetMergeRequestNoteCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, mergeRequest, note}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMergeRequestNote", reflect.TypeOf((*MockNotesServiceInterface)(nil).GetMergeRequestNote), varargs...)
	return &MockNotesServiceInterfaceGetMergeRequestNoteCall{Call: call}
}

// MockNotesServiceInterfaceGetMergeRequestNoteCall wrap *gomock.Call
type MockNotesServiceInterfaceGetMergeRequestNoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNotesServiceInterfaceGetMergeRequestNoteCall) Return(arg0 *gitlab.Note, arg1 *gitlab.Response, arg2 error) *MockNotesServiceInterfaceGetMergeRequestNoteCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNotesServiceInterfaceGetMergeRequestNoteCall) Do(f func(any, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceGetMergeRequestNoteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNotesServiceInterfaceGetMergeRequestNoteCall) DoAndReturn(f func(any, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceGetMergeRequestNoteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetSnippetNote mocks base method.
func (m *MockNotesServiceInterface) GetSnippetNote(pid any, snippet, note int, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, snippet, note}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetSnippetNote", varargs...)
	ret0, _ := ret[0].(*gitlab.Note)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetSnippetNote indicates an expected call of GetSnippetNote.
func (mr *MockNotesServiceInterfaceMockRecorder) GetSnippetNote(pid, snippet, note any, options ...any) *MockNotesServiceInterfaceGetSnippetNoteCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, snippet, note}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSnippetNote", reflect.TypeOf((*MockNotesServiceInterface)(nil).GetSnippetNote), varargs...)
	return &MockNotesServiceInterfaceGetSnippetNoteCall{Call: call}
}

// MockNotesServiceInterfaceGetSnippetNoteCall wrap *gomock.Call
type MockNotesServiceInterfaceGetSnippetNoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNotesServiceInterfaceGetSnippetNoteCall) Return(arg0 *gitlab.Note, arg1 *gitlab.Response, arg2 error) *MockNotesServiceInterfaceGetSnippetNoteCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNotesServiceInterfaceGetSnippetNoteCall) Do(f func(any, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceGetSnippetNoteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNotesServiceInterfaceGetSnippetNoteCall) DoAndReturn(f func(any, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceGetSnippetNoteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListEpicNotes mocks base method.
func (m *MockNotesServiceInterface) ListEpicNotes(gid any, epic int, opt *gitlab.ListEpicNotesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{gid, epic, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListEpicNotes", varargs...)
	ret0, _ := ret[0].([]*gitlab.Note)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListEpicNotes indicates an expected call of ListEpicNotes.
func (mr *MockNotesServiceInterfaceMockRecorder) ListEpicNotes(gid, epic, opt any, options ...any) *MockNotesServiceInterfaceListEpicNotesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{gid, epic, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListEpicNotes", reflect.TypeOf((*MockNotesServiceInterface)(nil).ListEpicNotes), varargs...)
	return &MockNotesServiceInterfaceListEpicNotesCall{Call: call}
}

// MockNotesServiceInterfaceListEpicNotesCall wrap *gomock.Call
type MockNotesServiceInterfaceListEpicNotesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNotesServiceInterfaceListEpicNotesCall) Return(arg0 []*gitlab.Note, arg1 *gitlab.Response, arg2 error) *MockNotesServiceInterfaceListEpicNotesCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNotesServiceInterfaceListEpicNotesCall) Do(f func(any, int, *gitlab.ListEpicNotesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceListEpicNotesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNotesServiceInterfaceListEpicNotesCall) DoAndReturn(f func(any, int, *gitlab.ListEpicNotesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceListEpicNotesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListIssueNotes mocks base method.
func (m *MockNotesServiceInterface) ListIssueNotes(pid any, issue int, opt *gitlab.ListIssueNotesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, issue, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListIssueNotes", varargs...)
	ret0, _ := ret[0].([]*gitlab.Note)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListIssueNotes indicates an expected call of ListIssueNotes.
func (mr *MockNotesServiceInterfaceMockRecorder) ListIssueNotes(pid, issue, opt any, options ...any) *MockNotesServiceInterfaceListIssueNotesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, issue, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListIssueNotes", reflect.TypeOf((*MockNotesServiceInterface)(nil).ListIssueNotes), varargs...)
	return &MockNotesServiceInterfaceListIssueNotesCall{Call: call}
}

// MockNotesServiceInterfaceListIssueNotesCall wrap *gomock.Call
type MockNotesServiceInterfaceListIssueNotesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNotesServiceInterfaceListIssueNotesCall) Return(arg0 []*gitlab.Note, arg1 *gitlab.Response, arg2 error) *MockNotesServiceInterfaceListIssueNotesCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNotesServiceInterfaceListIssueNotesCall) Do(f func(any, int, *gitlab.ListIssueNotesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceListIssueNotesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNotesServiceInterfaceListIssueNotesCall) DoAndReturn(f func(any, int, *gitlab.ListIssueNotesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceListIssueNotesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListMergeRequestNotes mocks base method.
func (m *MockNotesServiceInterface) ListMergeRequestNotes(pid any, mergeRequest int, opt *gitlab.ListMergeRequestNotesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, mergeRequest, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListMergeRequestNotes", varargs...)
	ret0, _ := ret[0].([]*gitlab.Note)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListMergeRequestNotes indicates an expected call of ListMergeRequestNotes.
func (mr *MockNotesServiceInterfaceMockRecorder) ListMergeRequestNotes(pid, mergeRequest, opt any, options ...any) *MockNotesServiceInterfaceListMergeRequestNotesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, mergeRequest, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListMergeRequestNotes", reflect.TypeOf((*MockNotesServiceInterface)(nil).ListMergeRequestNotes), varargs...)
	return &MockNotesServiceInterfaceListMergeRequestNotesCall{Call: call}
}

// MockNotesServiceInterfaceListMergeRequestNotesCall wrap *gomock.Call
type MockNotesServiceInterfaceListMergeRequestNotesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNotesServiceInterfaceListMergeRequestNotesCall) Return(arg0 []*gitlab.Note, arg1 *gitlab.Response, arg2 error) *MockNotesServiceInterfaceListMergeRequestNotesCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNotesServiceInterfaceListMergeRequestNotesCall) Do(f func(any, int, *gitlab.ListMergeRequestNotesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceListMergeRequestNotesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNotesServiceInterfaceListMergeRequestNotesCall) DoAndReturn(f func(any, int, *gitlab.ListMergeRequestNotesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceListMergeRequestNotesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListSnippetNotes mocks base method.
func (m *MockNotesServiceInterface) ListSnippetNotes(pid any, snippet int, opt *gitlab.ListSnippetNotesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, snippet, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListSnippetNotes", varargs...)
	ret0, _ := ret[0].([]*gitlab.Note)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListSnippetNotes indicates an expected call of ListSnippetNotes.
func (mr *MockNotesServiceInterfaceMockRecorder) ListSnippetNotes(pid, snippet, opt any, options ...any) *MockNotesServiceInterfaceListSnippetNotesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, snippet, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListSnippetNotes", reflect.TypeOf((*MockNotesServiceInterface)(nil).ListSnippetNotes), varargs...)
	return &MockNotesServiceInterfaceListSnippetNotesCall{Call: call}
}

// MockNotesServiceInterfaceListSnippetNotesCall wrap *gomock.Call
type MockNotesServiceInterfaceListSnippetNotesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNotesServiceInterfaceListSnippetNotesCall) Return(arg0 []*gitlab.Note, arg1 *gitlab.Response, arg2 error) *MockNotesServiceInterfaceListSnippetNotesCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNotesServiceInterfaceListSnippetNotesCall) Do(f func(any, int, *gitlab.ListSnippetNotesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceListSnippetNotesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNotesServiceInterfaceListSnippetNotesCall) DoAndReturn(f func(any, int, *gitlab.ListSnippetNotesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceListSnippetNotesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateEpicNote mocks base method.
func (m *MockNotesServiceInterface) UpdateEpicNote(gid any, epic, note int, opt *gitlab.UpdateEpicNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{gid, epic, note, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateEpicNote", varargs...)
	ret0, _ := ret[0].(*gitlab.Note)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// UpdateEpicNote indicates an expected call of UpdateEpicNote.
func (mr *MockNotesServiceInterfaceMockRecorder) UpdateEpicNote(gid, epic, note, opt any, options ...any) *MockNotesServiceInterfaceUpdateEpicNoteCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{gid, epic, note, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateEpicNote", reflect.TypeOf((*MockNotesServiceInterface)(nil).UpdateEpicNote), varargs...)
	return &MockNotesServiceInterfaceUpdateEpicNoteCall{Call: call}
}

// MockNotesServiceInterfaceUpdateEpicNoteCall wrap *gomock.Call
type MockNotesServiceInterfaceUpdateEpicNoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNotesServiceInterfaceUpdateEpicNoteCall) Return(arg0 *gitlab.Note, arg1 *gitlab.Response, arg2 error) *MockNotesServiceInterfaceUpdateEpicNoteCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNotesServiceInterfaceUpdateEpicNoteCall) Do(f func(any, int, int, *gitlab.UpdateEpicNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceUpdateEpicNoteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNotesServiceInterfaceUpdateEpicNoteCall) DoAndReturn(f func(any, int, int, *gitlab.UpdateEpicNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceUpdateEpicNoteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateIssueNote mocks base method.
func (m *MockNotesServiceInterface) UpdateIssueNote(pid any, issue, note int, opt *gitlab.UpdateIssueNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, issue, note, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateIssueNote", varargs...)
	ret0, _ := ret[0].(*gitlab.Note)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// UpdateIssueNote indicates an expected call of UpdateIssueNote.
func (mr *MockNotesServiceInterfaceMockRecorder) UpdateIssueNote(pid, issue, note, opt any, options ...any) *MockNotesServiceInterfaceUpdateIssueNoteCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, issue, note, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateIssueNote", reflect.TypeOf((*MockNotesServiceInterface)(nil).UpdateIssueNote), varargs...)
	return &MockNotesServiceInterfaceUpdateIssueNoteCall{Call: call}
}

// MockNotesServiceInterfaceUpdateIssueNoteCall wrap *gomock.Call
type MockNotesServiceInterfaceUpdateIssueNoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNotesServiceInterfaceUpdateIssueNoteCall) Return(arg0 *gitlab.Note, arg1 *gitlab.Response, arg2 error) *MockNotesServiceInterfaceUpdateIssueNoteCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNotesServiceInterfaceUpdateIssueNoteCall) Do(f func(any, int, int, *gitlab.UpdateIssueNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceUpdateIssueNoteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNotesServiceInterfaceUpdateIssueNoteCall) DoAndReturn(f func(any, int, int, *gitlab.UpdateIssueNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceUpdateIssueNoteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateMergeRequestNote mocks base method.
func (m *MockNotesServiceInterface) UpdateMergeRequestNote(pid any, mergeRequest, note int, opt *gitlab.UpdateMergeRequestNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, mergeRequest, note, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateMergeRequestNote", varargs...)
	ret0, _ := ret[0].(*gitlab.Note)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// UpdateMergeRequestNote indicates an expected call of UpdateMergeRequestNote.
func (mr *MockNotesServiceInterfaceMockRecorder) UpdateMergeRequestNote(pid, mergeRequest, note, opt any, options ...any) *MockNotesServiceInterfaceUpdateMergeRequestNoteCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, mergeRequest, note, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateMergeRequestNote", reflect.TypeOf((*MockNotesServiceInterface)(nil).UpdateMergeRequestNote), varargs...)
	return &MockNotesServiceInterfaceUpdateMergeRequestNoteCall{Call: call}
}

// MockNotesServiceInterfaceUpdateMergeRequestNoteCall wrap *gomock.Call
type MockNotesServiceInterfaceUpdateMergeRequestNoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNotesServiceInterfaceUpdateMergeRequestNoteCall) Return(arg0 *gitlab.Note, arg1 *gitlab.Response, arg2 error) *MockNotesServiceInterfaceUpdateMergeRequestNoteCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNotesServiceInterfaceUpdateMergeRequestNoteCall) Do(f func(any, int, int, *gitlab.UpdateMergeRequestNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceUpdateMergeRequestNoteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNotesServiceInterfaceUpdateMergeRequestNoteCall) DoAndReturn(f func(any, int, int, *gitlab.UpdateMergeRequestNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceUpdateMergeRequestNoteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateSnippetNote mocks base method.
func (m *MockNotesServiceInterface) UpdateSnippetNote(pid any, snippet, note int, opt *gitlab.UpdateSnippetNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, snippet, note, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateSnippetNote", varargs...)
	ret0, _ := ret[0].(*gitlab.Note)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// UpdateSnippetNote indicates an expected call of UpdateSnippetNote.
func (mr *MockNotesServiceInterfaceMockRecorder) UpdateSnippetNote(pid, snippet, note, opt any, options ...any) *MockNotesServiceInterfaceUpdateSnippetNoteCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, snippet, note, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateSnippetNote", reflect.TypeOf((*MockNotesServiceInterface)(nil).UpdateSnippetNote), varargs...)
	return &MockNotesServiceInterfaceUpdateSnippetNoteCall{Call: call}
}

// MockNotesServiceInterfaceUpdateSnippetNoteCall wrap *gomock.Call
type MockNotesServiceInterfaceUpdateSnippetNoteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNotesServiceInterfaceUpdateSnippetNoteCall) Return(arg0 *gitlab.Note, arg1 *gitlab.Response, arg2 error) *MockNotesServiceInterfaceUpdateSnippetNoteCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNotesServiceInterfaceUpdateSnippetNoteCall) Do(f func(any, int, int, *gitlab.UpdateSnippetNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceUpdateSnippetNoteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNotesServiceInterfaceUpdateSnippetNoteCall) DoAndReturn(f func(any, int, int, *gitlab.UpdateSnippetNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *MockNotesServiceInterfaceUpdateSnippetNoteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
