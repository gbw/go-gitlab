// Code generated by MockGen. DO NOT EDIT.
// Source: gitlab.com/gitlab-org/api/client-go (interfaces: ProjectsServiceInterface)
//
// Generated by this command:
//
//	mockgen -typed -destination=projects_mock.go -package=testing gitlab.com/gitlab-org/api/client-go ProjectsServiceInterface
//

// Package testing is a generated GoMock package.
package testing

import (
	bytes "bytes"
	io "io"
	reflect "reflect"

	gitlab "gitlab.com/gitlab-org/api/client-go"
	gomock "go.uber.org/mock/gomock"
)

// MockProjectsServiceInterface is a mock of ProjectsServiceInterface interface.
type MockProjectsServiceInterface struct {
	ctrl     *gomock.Controller
	recorder *MockProjectsServiceInterfaceMockRecorder
	isgomock struct{}
}

// MockProjectsServiceInterfaceMockRecorder is the mock recorder for MockProjectsServiceInterface.
type MockProjectsServiceInterfaceMockRecorder struct {
	mock *MockProjectsServiceInterface
}

// NewMockProjectsServiceInterface creates a new mock instance.
func NewMockProjectsServiceInterface(ctrl *gomock.Controller) *MockProjectsServiceInterface {
	mock := &MockProjectsServiceInterface{ctrl: ctrl}
	mock.recorder = &MockProjectsServiceInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProjectsServiceInterface) EXPECT() *MockProjectsServiceInterfaceMockRecorder {
	return m.recorder
}

// AddProjectHook mocks base method.
func (m *MockProjectsServiceInterface) AddProjectHook(pid any, opt *gitlab.AddProjectHookOptions, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectHook, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddProjectHook", varargs...)
	ret0, _ := ret[0].(*gitlab.ProjectHook)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// AddProjectHook indicates an expected call of AddProjectHook.
func (mr *MockProjectsServiceInterfaceMockRecorder) AddProjectHook(pid, opt any, options ...any) *MockProjectsServiceInterfaceAddProjectHookCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddProjectHook", reflect.TypeOf((*MockProjectsServiceInterface)(nil).AddProjectHook), varargs...)
	return &MockProjectsServiceInterfaceAddProjectHookCall{Call: call}
}

// MockProjectsServiceInterfaceAddProjectHookCall wrap *gomock.Call
type MockProjectsServiceInterfaceAddProjectHookCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceAddProjectHookCall) Return(arg0 *gitlab.ProjectHook, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceAddProjectHookCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceAddProjectHookCall) Do(f func(any, *gitlab.AddProjectHookOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectHook, *gitlab.Response, error)) *MockProjectsServiceInterfaceAddProjectHookCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceAddProjectHookCall) DoAndReturn(f func(any, *gitlab.AddProjectHookOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectHook, *gitlab.Response, error)) *MockProjectsServiceInterfaceAddProjectHookCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddProjectPushRule mocks base method.
func (m *MockProjectsServiceInterface) AddProjectPushRule(pid any, opt *gitlab.AddProjectPushRuleOptions, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectPushRules, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddProjectPushRule", varargs...)
	ret0, _ := ret[0].(*gitlab.ProjectPushRules)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// AddProjectPushRule indicates an expected call of AddProjectPushRule.
func (mr *MockProjectsServiceInterfaceMockRecorder) AddProjectPushRule(pid, opt any, options ...any) *MockProjectsServiceInterfaceAddProjectPushRuleCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddProjectPushRule", reflect.TypeOf((*MockProjectsServiceInterface)(nil).AddProjectPushRule), varargs...)
	return &MockProjectsServiceInterfaceAddProjectPushRuleCall{Call: call}
}

// MockProjectsServiceInterfaceAddProjectPushRuleCall wrap *gomock.Call
type MockProjectsServiceInterfaceAddProjectPushRuleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceAddProjectPushRuleCall) Return(arg0 *gitlab.ProjectPushRules, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceAddProjectPushRuleCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceAddProjectPushRuleCall) Do(f func(any, *gitlab.AddProjectPushRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectPushRules, *gitlab.Response, error)) *MockProjectsServiceInterfaceAddProjectPushRuleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceAddProjectPushRuleCall) DoAndReturn(f func(any, *gitlab.AddProjectPushRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectPushRules, *gitlab.Response, error)) *MockProjectsServiceInterfaceAddProjectPushRuleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ArchiveProject mocks base method.
func (m *MockProjectsServiceInterface) ArchiveProject(pid any, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ArchiveProject", varargs...)
	ret0, _ := ret[0].(*gitlab.Project)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ArchiveProject indicates an expected call of ArchiveProject.
func (mr *MockProjectsServiceInterfaceMockRecorder) ArchiveProject(pid any, options ...any) *MockProjectsServiceInterfaceArchiveProjectCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ArchiveProject", reflect.TypeOf((*MockProjectsServiceInterface)(nil).ArchiveProject), varargs...)
	return &MockProjectsServiceInterfaceArchiveProjectCall{Call: call}
}

// MockProjectsServiceInterfaceArchiveProjectCall wrap *gomock.Call
type MockProjectsServiceInterfaceArchiveProjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceArchiveProjectCall) Return(arg0 *gitlab.Project, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceArchiveProjectCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceArchiveProjectCall) Do(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceArchiveProjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceArchiveProjectCall) DoAndReturn(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceArchiveProjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ChangeApprovalConfiguration mocks base method.
func (m *MockProjectsServiceInterface) ChangeApprovalConfiguration(pid any, opt *gitlab.ChangeApprovalConfigurationOptions, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovals, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ChangeApprovalConfiguration", varargs...)
	ret0, _ := ret[0].(*gitlab.ProjectApprovals)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ChangeApprovalConfiguration indicates an expected call of ChangeApprovalConfiguration.
func (mr *MockProjectsServiceInterfaceMockRecorder) ChangeApprovalConfiguration(pid, opt any, options ...any) *MockProjectsServiceInterfaceChangeApprovalConfigurationCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChangeApprovalConfiguration", reflect.TypeOf((*MockProjectsServiceInterface)(nil).ChangeApprovalConfiguration), varargs...)
	return &MockProjectsServiceInterfaceChangeApprovalConfigurationCall{Call: call}
}

// MockProjectsServiceInterfaceChangeApprovalConfigurationCall wrap *gomock.Call
type MockProjectsServiceInterfaceChangeApprovalConfigurationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceChangeApprovalConfigurationCall) Return(arg0 *gitlab.ProjectApprovals, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceChangeApprovalConfigurationCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceChangeApprovalConfigurationCall) Do(f func(any, *gitlab.ChangeApprovalConfigurationOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovals, *gitlab.Response, error)) *MockProjectsServiceInterfaceChangeApprovalConfigurationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceChangeApprovalConfigurationCall) DoAndReturn(f func(any, *gitlab.ChangeApprovalConfigurationOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovals, *gitlab.Response, error)) *MockProjectsServiceInterfaceChangeApprovalConfigurationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ConfigureProjectPullMirror mocks base method.
func (m *MockProjectsServiceInterface) ConfigureProjectPullMirror(pid any, opt *gitlab.ConfigureProjectPullMirrorOptions, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectPullMirrorDetails, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ConfigureProjectPullMirror", varargs...)
	ret0, _ := ret[0].(*gitlab.ProjectPullMirrorDetails)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ConfigureProjectPullMirror indicates an expected call of ConfigureProjectPullMirror.
func (mr *MockProjectsServiceInterfaceMockRecorder) ConfigureProjectPullMirror(pid, opt any, options ...any) *MockProjectsServiceInterfaceConfigureProjectPullMirrorCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConfigureProjectPullMirror", reflect.TypeOf((*MockProjectsServiceInterface)(nil).ConfigureProjectPullMirror), varargs...)
	return &MockProjectsServiceInterfaceConfigureProjectPullMirrorCall{Call: call}
}

// MockProjectsServiceInterfaceConfigureProjectPullMirrorCall wrap *gomock.Call
type MockProjectsServiceInterfaceConfigureProjectPullMirrorCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceConfigureProjectPullMirrorCall) Return(arg0 *gitlab.ProjectPullMirrorDetails, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceConfigureProjectPullMirrorCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceConfigureProjectPullMirrorCall) Do(f func(any, *gitlab.ConfigureProjectPullMirrorOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectPullMirrorDetails, *gitlab.Response, error)) *MockProjectsServiceInterfaceConfigureProjectPullMirrorCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceConfigureProjectPullMirrorCall) DoAndReturn(f func(any, *gitlab.ConfigureProjectPullMirrorOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectPullMirrorDetails, *gitlab.Response, error)) *MockProjectsServiceInterfaceConfigureProjectPullMirrorCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateProject mocks base method.
func (m *MockProjectsServiceInterface) CreateProject(opt *gitlab.CreateProjectOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateProject", varargs...)
	ret0, _ := ret[0].(*gitlab.Project)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreateProject indicates an expected call of CreateProject.
func (mr *MockProjectsServiceInterfaceMockRecorder) CreateProject(opt any, options ...any) *MockProjectsServiceInterfaceCreateProjectCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateProject", reflect.TypeOf((*MockProjectsServiceInterface)(nil).CreateProject), varargs...)
	return &MockProjectsServiceInterfaceCreateProjectCall{Call: call}
}

// MockProjectsServiceInterfaceCreateProjectCall wrap *gomock.Call
type MockProjectsServiceInterfaceCreateProjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceCreateProjectCall) Return(arg0 *gitlab.Project, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceCreateProjectCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceCreateProjectCall) Do(f func(*gitlab.CreateProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceCreateProjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceCreateProjectCall) DoAndReturn(f func(*gitlab.CreateProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceCreateProjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateProjectApprovalRule mocks base method.
func (m *MockProjectsServiceInterface) CreateProjectApprovalRule(pid any, opt *gitlab.CreateProjectLevelRuleOptions, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovalRule, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateProjectApprovalRule", varargs...)
	ret0, _ := ret[0].(*gitlab.ProjectApprovalRule)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreateProjectApprovalRule indicates an expected call of CreateProjectApprovalRule.
func (mr *MockProjectsServiceInterfaceMockRecorder) CreateProjectApprovalRule(pid, opt any, options ...any) *MockProjectsServiceInterfaceCreateProjectApprovalRuleCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateProjectApprovalRule", reflect.TypeOf((*MockProjectsServiceInterface)(nil).CreateProjectApprovalRule), varargs...)
	return &MockProjectsServiceInterfaceCreateProjectApprovalRuleCall{Call: call}
}

// MockProjectsServiceInterfaceCreateProjectApprovalRuleCall wrap *gomock.Call
type MockProjectsServiceInterfaceCreateProjectApprovalRuleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceCreateProjectApprovalRuleCall) Return(arg0 *gitlab.ProjectApprovalRule, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceCreateProjectApprovalRuleCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceCreateProjectApprovalRuleCall) Do(f func(any, *gitlab.CreateProjectLevelRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovalRule, *gitlab.Response, error)) *MockProjectsServiceInterfaceCreateProjectApprovalRuleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceCreateProjectApprovalRuleCall) DoAndReturn(f func(any, *gitlab.CreateProjectLevelRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovalRule, *gitlab.Response, error)) *MockProjectsServiceInterfaceCreateProjectApprovalRuleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateProjectForUser mocks base method.
func (m *MockProjectsServiceInterface) CreateProjectForUser(user int, opt *gitlab.CreateProjectForUserOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{user, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateProjectForUser", varargs...)
	ret0, _ := ret[0].(*gitlab.Project)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreateProjectForUser indicates an expected call of CreateProjectForUser.
func (mr *MockProjectsServiceInterfaceMockRecorder) CreateProjectForUser(user, opt any, options ...any) *MockProjectsServiceInterfaceCreateProjectForUserCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{user, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateProjectForUser", reflect.TypeOf((*MockProjectsServiceInterface)(nil).CreateProjectForUser), varargs...)
	return &MockProjectsServiceInterfaceCreateProjectForUserCall{Call: call}
}

// MockProjectsServiceInterfaceCreateProjectForUserCall wrap *gomock.Call
type MockProjectsServiceInterfaceCreateProjectForUserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceCreateProjectForUserCall) Return(arg0 *gitlab.Project, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceCreateProjectForUserCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceCreateProjectForUserCall) Do(f func(int, *gitlab.CreateProjectForUserOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceCreateProjectForUserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceCreateProjectForUserCall) DoAndReturn(f func(int, *gitlab.CreateProjectForUserOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceCreateProjectForUserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateProjectForkRelation mocks base method.
func (m *MockProjectsServiceInterface) CreateProjectForkRelation(pid any, fork int, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectForkRelation, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, fork}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateProjectForkRelation", varargs...)
	ret0, _ := ret[0].(*gitlab.ProjectForkRelation)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreateProjectForkRelation indicates an expected call of CreateProjectForkRelation.
func (mr *MockProjectsServiceInterfaceMockRecorder) CreateProjectForkRelation(pid, fork any, options ...any) *MockProjectsServiceInterfaceCreateProjectForkRelationCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, fork}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateProjectForkRelation", reflect.TypeOf((*MockProjectsServiceInterface)(nil).CreateProjectForkRelation), varargs...)
	return &MockProjectsServiceInterfaceCreateProjectForkRelationCall{Call: call}
}

// MockProjectsServiceInterfaceCreateProjectForkRelationCall wrap *gomock.Call
type MockProjectsServiceInterfaceCreateProjectForkRelationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceCreateProjectForkRelationCall) Return(arg0 *gitlab.ProjectForkRelation, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceCreateProjectForkRelationCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceCreateProjectForkRelationCall) Do(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.ProjectForkRelation, *gitlab.Response, error)) *MockProjectsServiceInterfaceCreateProjectForkRelationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceCreateProjectForkRelationCall) DoAndReturn(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.ProjectForkRelation, *gitlab.Response, error)) *MockProjectsServiceInterfaceCreateProjectForkRelationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteProject mocks base method.
func (m *MockProjectsServiceInterface) DeleteProject(pid any, opt *gitlab.DeleteProjectOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteProject", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteProject indicates an expected call of DeleteProject.
func (mr *MockProjectsServiceInterfaceMockRecorder) DeleteProject(pid, opt any, options ...any) *MockProjectsServiceInterfaceDeleteProjectCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteProject", reflect.TypeOf((*MockProjectsServiceInterface)(nil).DeleteProject), varargs...)
	return &MockProjectsServiceInterfaceDeleteProjectCall{Call: call}
}

// MockProjectsServiceInterfaceDeleteProjectCall wrap *gomock.Call
type MockProjectsServiceInterfaceDeleteProjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceDeleteProjectCall) Return(arg0 *gitlab.Response, arg1 error) *MockProjectsServiceInterfaceDeleteProjectCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceDeleteProjectCall) Do(f func(any, *gitlab.DeleteProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceDeleteProjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceDeleteProjectCall) DoAndReturn(f func(any, *gitlab.DeleteProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceDeleteProjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteProjectApprovalRule mocks base method.
func (m *MockProjectsServiceInterface) DeleteProjectApprovalRule(pid any, approvalRule int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, approvalRule}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteProjectApprovalRule", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteProjectApprovalRule indicates an expected call of DeleteProjectApprovalRule.
func (mr *MockProjectsServiceInterfaceMockRecorder) DeleteProjectApprovalRule(pid, approvalRule any, options ...any) *MockProjectsServiceInterfaceDeleteProjectApprovalRuleCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, approvalRule}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteProjectApprovalRule", reflect.TypeOf((*MockProjectsServiceInterface)(nil).DeleteProjectApprovalRule), varargs...)
	return &MockProjectsServiceInterfaceDeleteProjectApprovalRuleCall{Call: call}
}

// MockProjectsServiceInterfaceDeleteProjectApprovalRuleCall wrap *gomock.Call
type MockProjectsServiceInterfaceDeleteProjectApprovalRuleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceDeleteProjectApprovalRuleCall) Return(arg0 *gitlab.Response, arg1 error) *MockProjectsServiceInterfaceDeleteProjectApprovalRuleCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceDeleteProjectApprovalRuleCall) Do(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceDeleteProjectApprovalRuleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceDeleteProjectApprovalRuleCall) DoAndReturn(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceDeleteProjectApprovalRuleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteProjectCustomHeader mocks base method.
func (m *MockProjectsServiceInterface) DeleteProjectCustomHeader(pid any, hook int, key string, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, hook, key}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteProjectCustomHeader", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteProjectCustomHeader indicates an expected call of DeleteProjectCustomHeader.
func (mr *MockProjectsServiceInterfaceMockRecorder) DeleteProjectCustomHeader(pid, hook, key any, options ...any) *MockProjectsServiceInterfaceDeleteProjectCustomHeaderCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, hook, key}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteProjectCustomHeader", reflect.TypeOf((*MockProjectsServiceInterface)(nil).DeleteProjectCustomHeader), varargs...)
	return &MockProjectsServiceInterfaceDeleteProjectCustomHeaderCall{Call: call}
}

// MockProjectsServiceInterfaceDeleteProjectCustomHeaderCall wrap *gomock.Call
type MockProjectsServiceInterfaceDeleteProjectCustomHeaderCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceDeleteProjectCustomHeaderCall) Return(arg0 *gitlab.Response, arg1 error) *MockProjectsServiceInterfaceDeleteProjectCustomHeaderCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceDeleteProjectCustomHeaderCall) Do(f func(any, int, string, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceDeleteProjectCustomHeaderCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceDeleteProjectCustomHeaderCall) DoAndReturn(f func(any, int, string, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceDeleteProjectCustomHeaderCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteProjectForkRelation mocks base method.
func (m *MockProjectsServiceInterface) DeleteProjectForkRelation(pid any, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteProjectForkRelation", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteProjectForkRelation indicates an expected call of DeleteProjectForkRelation.
func (mr *MockProjectsServiceInterfaceMockRecorder) DeleteProjectForkRelation(pid any, options ...any) *MockProjectsServiceInterfaceDeleteProjectForkRelationCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteProjectForkRelation", reflect.TypeOf((*MockProjectsServiceInterface)(nil).DeleteProjectForkRelation), varargs...)
	return &MockProjectsServiceInterfaceDeleteProjectForkRelationCall{Call: call}
}

// MockProjectsServiceInterfaceDeleteProjectForkRelationCall wrap *gomock.Call
type MockProjectsServiceInterfaceDeleteProjectForkRelationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceDeleteProjectForkRelationCall) Return(arg0 *gitlab.Response, arg1 error) *MockProjectsServiceInterfaceDeleteProjectForkRelationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceDeleteProjectForkRelationCall) Do(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceDeleteProjectForkRelationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceDeleteProjectForkRelationCall) DoAndReturn(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceDeleteProjectForkRelationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteProjectHook mocks base method.
func (m *MockProjectsServiceInterface) DeleteProjectHook(pid any, hook int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, hook}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteProjectHook", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteProjectHook indicates an expected call of DeleteProjectHook.
func (mr *MockProjectsServiceInterfaceMockRecorder) DeleteProjectHook(pid, hook any, options ...any) *MockProjectsServiceInterfaceDeleteProjectHookCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, hook}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteProjectHook", reflect.TypeOf((*MockProjectsServiceInterface)(nil).DeleteProjectHook), varargs...)
	return &MockProjectsServiceInterfaceDeleteProjectHookCall{Call: call}
}

// MockProjectsServiceInterfaceDeleteProjectHookCall wrap *gomock.Call
type MockProjectsServiceInterfaceDeleteProjectHookCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceDeleteProjectHookCall) Return(arg0 *gitlab.Response, arg1 error) *MockProjectsServiceInterfaceDeleteProjectHookCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceDeleteProjectHookCall) Do(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceDeleteProjectHookCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceDeleteProjectHookCall) DoAndReturn(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceDeleteProjectHookCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteProjectPushRule mocks base method.
func (m *MockProjectsServiceInterface) DeleteProjectPushRule(pid any, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteProjectPushRule", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteProjectPushRule indicates an expected call of DeleteProjectPushRule.
func (mr *MockProjectsServiceInterfaceMockRecorder) DeleteProjectPushRule(pid any, options ...any) *MockProjectsServiceInterfaceDeleteProjectPushRuleCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteProjectPushRule", reflect.TypeOf((*MockProjectsServiceInterface)(nil).DeleteProjectPushRule), varargs...)
	return &MockProjectsServiceInterfaceDeleteProjectPushRuleCall{Call: call}
}

// MockProjectsServiceInterfaceDeleteProjectPushRuleCall wrap *gomock.Call
type MockProjectsServiceInterfaceDeleteProjectPushRuleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceDeleteProjectPushRuleCall) Return(arg0 *gitlab.Response, arg1 error) *MockProjectsServiceInterfaceDeleteProjectPushRuleCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceDeleteProjectPushRuleCall) Do(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceDeleteProjectPushRuleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceDeleteProjectPushRuleCall) DoAndReturn(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceDeleteProjectPushRuleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteSharedProjectFromGroup mocks base method.
func (m *MockProjectsServiceInterface) DeleteSharedProjectFromGroup(pid any, groupID int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, groupID}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteSharedProjectFromGroup", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteSharedProjectFromGroup indicates an expected call of DeleteSharedProjectFromGroup.
func (mr *MockProjectsServiceInterfaceMockRecorder) DeleteSharedProjectFromGroup(pid, groupID any, options ...any) *MockProjectsServiceInterfaceDeleteSharedProjectFromGroupCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, groupID}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSharedProjectFromGroup", reflect.TypeOf((*MockProjectsServiceInterface)(nil).DeleteSharedProjectFromGroup), varargs...)
	return &MockProjectsServiceInterfaceDeleteSharedProjectFromGroupCall{Call: call}
}

// MockProjectsServiceInterfaceDeleteSharedProjectFromGroupCall wrap *gomock.Call
type MockProjectsServiceInterfaceDeleteSharedProjectFromGroupCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceDeleteSharedProjectFromGroupCall) Return(arg0 *gitlab.Response, arg1 error) *MockProjectsServiceInterfaceDeleteSharedProjectFromGroupCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceDeleteSharedProjectFromGroupCall) Do(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceDeleteSharedProjectFromGroupCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceDeleteSharedProjectFromGroupCall) DoAndReturn(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceDeleteSharedProjectFromGroupCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DownloadAvatar mocks base method.
func (m *MockProjectsServiceInterface) DownloadAvatar(pid any, options ...gitlab.RequestOptionFunc) (*bytes.Reader, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DownloadAvatar", varargs...)
	ret0, _ := ret[0].(*bytes.Reader)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// DownloadAvatar indicates an expected call of DownloadAvatar.
func (mr *MockProjectsServiceInterfaceMockRecorder) DownloadAvatar(pid any, options ...any) *MockProjectsServiceInterfaceDownloadAvatarCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DownloadAvatar", reflect.TypeOf((*MockProjectsServiceInterface)(nil).DownloadAvatar), varargs...)
	return &MockProjectsServiceInterfaceDownloadAvatarCall{Call: call}
}

// MockProjectsServiceInterfaceDownloadAvatarCall wrap *gomock.Call
type MockProjectsServiceInterfaceDownloadAvatarCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceDownloadAvatarCall) Return(arg0 *bytes.Reader, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceDownloadAvatarCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceDownloadAvatarCall) Do(f func(any, ...gitlab.RequestOptionFunc) (*bytes.Reader, *gitlab.Response, error)) *MockProjectsServiceInterfaceDownloadAvatarCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceDownloadAvatarCall) DoAndReturn(f func(any, ...gitlab.RequestOptionFunc) (*bytes.Reader, *gitlab.Response, error)) *MockProjectsServiceInterfaceDownloadAvatarCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// EditProject mocks base method.
func (m *MockProjectsServiceInterface) EditProject(pid any, opt *gitlab.EditProjectOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "EditProject", varargs...)
	ret0, _ := ret[0].(*gitlab.Project)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// EditProject indicates an expected call of EditProject.
func (mr *MockProjectsServiceInterfaceMockRecorder) EditProject(pid, opt any, options ...any) *MockProjectsServiceInterfaceEditProjectCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EditProject", reflect.TypeOf((*MockProjectsServiceInterface)(nil).EditProject), varargs...)
	return &MockProjectsServiceInterfaceEditProjectCall{Call: call}
}

// MockProjectsServiceInterfaceEditProjectCall wrap *gomock.Call
type MockProjectsServiceInterfaceEditProjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceEditProjectCall) Return(arg0 *gitlab.Project, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceEditProjectCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceEditProjectCall) Do(f func(any, *gitlab.EditProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceEditProjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceEditProjectCall) DoAndReturn(f func(any, *gitlab.EditProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceEditProjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// EditProjectHook mocks base method.
func (m *MockProjectsServiceInterface) EditProjectHook(pid any, hook int, opt *gitlab.EditProjectHookOptions, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectHook, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, hook, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "EditProjectHook", varargs...)
	ret0, _ := ret[0].(*gitlab.ProjectHook)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// EditProjectHook indicates an expected call of EditProjectHook.
func (mr *MockProjectsServiceInterfaceMockRecorder) EditProjectHook(pid, hook, opt any, options ...any) *MockProjectsServiceInterfaceEditProjectHookCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, hook, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EditProjectHook", reflect.TypeOf((*MockProjectsServiceInterface)(nil).EditProjectHook), varargs...)
	return &MockProjectsServiceInterfaceEditProjectHookCall{Call: call}
}

// MockProjectsServiceInterfaceEditProjectHookCall wrap *gomock.Call
type MockProjectsServiceInterfaceEditProjectHookCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceEditProjectHookCall) Return(arg0 *gitlab.ProjectHook, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceEditProjectHookCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceEditProjectHookCall) Do(f func(any, int, *gitlab.EditProjectHookOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectHook, *gitlab.Response, error)) *MockProjectsServiceInterfaceEditProjectHookCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceEditProjectHookCall) DoAndReturn(f func(any, int, *gitlab.EditProjectHookOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectHook, *gitlab.Response, error)) *MockProjectsServiceInterfaceEditProjectHookCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// EditProjectPushRule mocks base method.
func (m *MockProjectsServiceInterface) EditProjectPushRule(pid any, opt *gitlab.EditProjectPushRuleOptions, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectPushRules, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "EditProjectPushRule", varargs...)
	ret0, _ := ret[0].(*gitlab.ProjectPushRules)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// EditProjectPushRule indicates an expected call of EditProjectPushRule.
func (mr *MockProjectsServiceInterfaceMockRecorder) EditProjectPushRule(pid, opt any, options ...any) *MockProjectsServiceInterfaceEditProjectPushRuleCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EditProjectPushRule", reflect.TypeOf((*MockProjectsServiceInterface)(nil).EditProjectPushRule), varargs...)
	return &MockProjectsServiceInterfaceEditProjectPushRuleCall{Call: call}
}

// MockProjectsServiceInterfaceEditProjectPushRuleCall wrap *gomock.Call
type MockProjectsServiceInterfaceEditProjectPushRuleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceEditProjectPushRuleCall) Return(arg0 *gitlab.ProjectPushRules, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceEditProjectPushRuleCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceEditProjectPushRuleCall) Do(f func(any, *gitlab.EditProjectPushRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectPushRules, *gitlab.Response, error)) *MockProjectsServiceInterfaceEditProjectPushRuleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceEditProjectPushRuleCall) DoAndReturn(f func(any, *gitlab.EditProjectPushRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectPushRules, *gitlab.Response, error)) *MockProjectsServiceInterfaceEditProjectPushRuleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ForkProject mocks base method.
func (m *MockProjectsServiceInterface) ForkProject(pid any, opt *gitlab.ForkProjectOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ForkProject", varargs...)
	ret0, _ := ret[0].(*gitlab.Project)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ForkProject indicates an expected call of ForkProject.
func (mr *MockProjectsServiceInterfaceMockRecorder) ForkProject(pid, opt any, options ...any) *MockProjectsServiceInterfaceForkProjectCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ForkProject", reflect.TypeOf((*MockProjectsServiceInterface)(nil).ForkProject), varargs...)
	return &MockProjectsServiceInterfaceForkProjectCall{Call: call}
}

// MockProjectsServiceInterfaceForkProjectCall wrap *gomock.Call
type MockProjectsServiceInterfaceForkProjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceForkProjectCall) Return(arg0 *gitlab.Project, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceForkProjectCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceForkProjectCall) Do(f func(any, *gitlab.ForkProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceForkProjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceForkProjectCall) DoAndReturn(f func(any, *gitlab.ForkProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceForkProjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetApprovalConfiguration mocks base method.
func (m *MockProjectsServiceInterface) GetApprovalConfiguration(pid any, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovals, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetApprovalConfiguration", varargs...)
	ret0, _ := ret[0].(*gitlab.ProjectApprovals)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetApprovalConfiguration indicates an expected call of GetApprovalConfiguration.
func (mr *MockProjectsServiceInterfaceMockRecorder) GetApprovalConfiguration(pid any, options ...any) *MockProjectsServiceInterfaceGetApprovalConfigurationCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetApprovalConfiguration", reflect.TypeOf((*MockProjectsServiceInterface)(nil).GetApprovalConfiguration), varargs...)
	return &MockProjectsServiceInterfaceGetApprovalConfigurationCall{Call: call}
}

// MockProjectsServiceInterfaceGetApprovalConfigurationCall wrap *gomock.Call
type MockProjectsServiceInterfaceGetApprovalConfigurationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceGetApprovalConfigurationCall) Return(arg0 *gitlab.ProjectApprovals, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceGetApprovalConfigurationCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceGetApprovalConfigurationCall) Do(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovals, *gitlab.Response, error)) *MockProjectsServiceInterfaceGetApprovalConfigurationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceGetApprovalConfigurationCall) DoAndReturn(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovals, *gitlab.Response, error)) *MockProjectsServiceInterfaceGetApprovalConfigurationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetProject mocks base method.
func (m *MockProjectsServiceInterface) GetProject(pid any, opt *gitlab.GetProjectOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetProject", varargs...)
	ret0, _ := ret[0].(*gitlab.Project)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetProject indicates an expected call of GetProject.
func (mr *MockProjectsServiceInterfaceMockRecorder) GetProject(pid, opt any, options ...any) *MockProjectsServiceInterfaceGetProjectCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetProject", reflect.TypeOf((*MockProjectsServiceInterface)(nil).GetProject), varargs...)
	return &MockProjectsServiceInterfaceGetProjectCall{Call: call}
}

// MockProjectsServiceInterfaceGetProjectCall wrap *gomock.Call
type MockProjectsServiceInterfaceGetProjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceGetProjectCall) Return(arg0 *gitlab.Project, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceGetProjectCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceGetProjectCall) Do(f func(any, *gitlab.GetProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceGetProjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceGetProjectCall) DoAndReturn(f func(any, *gitlab.GetProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceGetProjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetProjectApprovalRule mocks base method.
func (m *MockProjectsServiceInterface) GetProjectApprovalRule(pid any, ruleID int, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovalRule, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, ruleID}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetProjectApprovalRule", varargs...)
	ret0, _ := ret[0].(*gitlab.ProjectApprovalRule)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetProjectApprovalRule indicates an expected call of GetProjectApprovalRule.
func (mr *MockProjectsServiceInterfaceMockRecorder) GetProjectApprovalRule(pid, ruleID any, options ...any) *MockProjectsServiceInterfaceGetProjectApprovalRuleCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, ruleID}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetProjectApprovalRule", reflect.TypeOf((*MockProjectsServiceInterface)(nil).GetProjectApprovalRule), varargs...)
	return &MockProjectsServiceInterfaceGetProjectApprovalRuleCall{Call: call}
}

// MockProjectsServiceInterfaceGetProjectApprovalRuleCall wrap *gomock.Call
type MockProjectsServiceInterfaceGetProjectApprovalRuleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceGetProjectApprovalRuleCall) Return(arg0 *gitlab.ProjectApprovalRule, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceGetProjectApprovalRuleCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceGetProjectApprovalRuleCall) Do(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovalRule, *gitlab.Response, error)) *MockProjectsServiceInterfaceGetProjectApprovalRuleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceGetProjectApprovalRuleCall) DoAndReturn(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovalRule, *gitlab.Response, error)) *MockProjectsServiceInterfaceGetProjectApprovalRuleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetProjectApprovalRules mocks base method.
func (m *MockProjectsServiceInterface) GetProjectApprovalRules(pid any, opt *gitlab.GetProjectApprovalRulesListsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectApprovalRule, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetProjectApprovalRules", varargs...)
	ret0, _ := ret[0].([]*gitlab.ProjectApprovalRule)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetProjectApprovalRules indicates an expected call of GetProjectApprovalRules.
func (mr *MockProjectsServiceInterfaceMockRecorder) GetProjectApprovalRules(pid, opt any, options ...any) *MockProjectsServiceInterfaceGetProjectApprovalRulesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetProjectApprovalRules", reflect.TypeOf((*MockProjectsServiceInterface)(nil).GetProjectApprovalRules), varargs...)
	return &MockProjectsServiceInterfaceGetProjectApprovalRulesCall{Call: call}
}

// MockProjectsServiceInterfaceGetProjectApprovalRulesCall wrap *gomock.Call
type MockProjectsServiceInterfaceGetProjectApprovalRulesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceGetProjectApprovalRulesCall) Return(arg0 []*gitlab.ProjectApprovalRule, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceGetProjectApprovalRulesCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceGetProjectApprovalRulesCall) Do(f func(any, *gitlab.GetProjectApprovalRulesListsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectApprovalRule, *gitlab.Response, error)) *MockProjectsServiceInterfaceGetProjectApprovalRulesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceGetProjectApprovalRulesCall) DoAndReturn(f func(any, *gitlab.GetProjectApprovalRulesListsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectApprovalRule, *gitlab.Response, error)) *MockProjectsServiceInterfaceGetProjectApprovalRulesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetProjectHook mocks base method.
func (m *MockProjectsServiceInterface) GetProjectHook(pid any, hook int, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectHook, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, hook}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetProjectHook", varargs...)
	ret0, _ := ret[0].(*gitlab.ProjectHook)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetProjectHook indicates an expected call of GetProjectHook.
func (mr *MockProjectsServiceInterfaceMockRecorder) GetProjectHook(pid, hook any, options ...any) *MockProjectsServiceInterfaceGetProjectHookCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, hook}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetProjectHook", reflect.TypeOf((*MockProjectsServiceInterface)(nil).GetProjectHook), varargs...)
	return &MockProjectsServiceInterfaceGetProjectHookCall{Call: call}
}

// MockProjectsServiceInterfaceGetProjectHookCall wrap *gomock.Call
type MockProjectsServiceInterfaceGetProjectHookCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceGetProjectHookCall) Return(arg0 *gitlab.ProjectHook, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceGetProjectHookCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceGetProjectHookCall) Do(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.ProjectHook, *gitlab.Response, error)) *MockProjectsServiceInterfaceGetProjectHookCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceGetProjectHookCall) DoAndReturn(f func(any, int, ...gitlab.RequestOptionFunc) (*gitlab.ProjectHook, *gitlab.Response, error)) *MockProjectsServiceInterfaceGetProjectHookCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetProjectLanguages mocks base method.
func (m *MockProjectsServiceInterface) GetProjectLanguages(pid any, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectLanguages, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetProjectLanguages", varargs...)
	ret0, _ := ret[0].(*gitlab.ProjectLanguages)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetProjectLanguages indicates an expected call of GetProjectLanguages.
func (mr *MockProjectsServiceInterfaceMockRecorder) GetProjectLanguages(pid any, options ...any) *MockProjectsServiceInterfaceGetProjectLanguagesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetProjectLanguages", reflect.TypeOf((*MockProjectsServiceInterface)(nil).GetProjectLanguages), varargs...)
	return &MockProjectsServiceInterfaceGetProjectLanguagesCall{Call: call}
}

// MockProjectsServiceInterfaceGetProjectLanguagesCall wrap *gomock.Call
type MockProjectsServiceInterfaceGetProjectLanguagesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceGetProjectLanguagesCall) Return(arg0 *gitlab.ProjectLanguages, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceGetProjectLanguagesCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceGetProjectLanguagesCall) Do(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.ProjectLanguages, *gitlab.Response, error)) *MockProjectsServiceInterfaceGetProjectLanguagesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceGetProjectLanguagesCall) DoAndReturn(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.ProjectLanguages, *gitlab.Response, error)) *MockProjectsServiceInterfaceGetProjectLanguagesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetProjectPullMirrorDetails mocks base method.
func (m *MockProjectsServiceInterface) GetProjectPullMirrorDetails(pid any, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectPullMirrorDetails, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetProjectPullMirrorDetails", varargs...)
	ret0, _ := ret[0].(*gitlab.ProjectPullMirrorDetails)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetProjectPullMirrorDetails indicates an expected call of GetProjectPullMirrorDetails.
func (mr *MockProjectsServiceInterfaceMockRecorder) GetProjectPullMirrorDetails(pid any, options ...any) *MockProjectsServiceInterfaceGetProjectPullMirrorDetailsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetProjectPullMirrorDetails", reflect.TypeOf((*MockProjectsServiceInterface)(nil).GetProjectPullMirrorDetails), varargs...)
	return &MockProjectsServiceInterfaceGetProjectPullMirrorDetailsCall{Call: call}
}

// MockProjectsServiceInterfaceGetProjectPullMirrorDetailsCall wrap *gomock.Call
type MockProjectsServiceInterfaceGetProjectPullMirrorDetailsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceGetProjectPullMirrorDetailsCall) Return(arg0 *gitlab.ProjectPullMirrorDetails, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceGetProjectPullMirrorDetailsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceGetProjectPullMirrorDetailsCall) Do(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.ProjectPullMirrorDetails, *gitlab.Response, error)) *MockProjectsServiceInterfaceGetProjectPullMirrorDetailsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceGetProjectPullMirrorDetailsCall) DoAndReturn(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.ProjectPullMirrorDetails, *gitlab.Response, error)) *MockProjectsServiceInterfaceGetProjectPullMirrorDetailsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetProjectPushRules mocks base method.
func (m *MockProjectsServiceInterface) GetProjectPushRules(pid any, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectPushRules, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetProjectPushRules", varargs...)
	ret0, _ := ret[0].(*gitlab.ProjectPushRules)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetProjectPushRules indicates an expected call of GetProjectPushRules.
func (mr *MockProjectsServiceInterfaceMockRecorder) GetProjectPushRules(pid any, options ...any) *MockProjectsServiceInterfaceGetProjectPushRulesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetProjectPushRules", reflect.TypeOf((*MockProjectsServiceInterface)(nil).GetProjectPushRules), varargs...)
	return &MockProjectsServiceInterfaceGetProjectPushRulesCall{Call: call}
}

// MockProjectsServiceInterfaceGetProjectPushRulesCall wrap *gomock.Call
type MockProjectsServiceInterfaceGetProjectPushRulesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceGetProjectPushRulesCall) Return(arg0 *gitlab.ProjectPushRules, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceGetProjectPushRulesCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceGetProjectPushRulesCall) Do(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.ProjectPushRules, *gitlab.Response, error)) *MockProjectsServiceInterfaceGetProjectPushRulesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceGetProjectPushRulesCall) DoAndReturn(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.ProjectPushRules, *gitlab.Response, error)) *MockProjectsServiceInterfaceGetProjectPushRulesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetRepositoryStorage mocks base method.
func (m *MockProjectsServiceInterface) GetRepositoryStorage(pid any, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectReposityStorage, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetRepositoryStorage", varargs...)
	ret0, _ := ret[0].(*gitlab.ProjectReposityStorage)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetRepositoryStorage indicates an expected call of GetRepositoryStorage.
func (mr *MockProjectsServiceInterfaceMockRecorder) GetRepositoryStorage(pid any, options ...any) *MockProjectsServiceInterfaceGetRepositoryStorageCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRepositoryStorage", reflect.TypeOf((*MockProjectsServiceInterface)(nil).GetRepositoryStorage), varargs...)
	return &MockProjectsServiceInterfaceGetRepositoryStorageCall{Call: call}
}

// MockProjectsServiceInterfaceGetRepositoryStorageCall wrap *gomock.Call
type MockProjectsServiceInterfaceGetRepositoryStorageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceGetRepositoryStorageCall) Return(arg0 *gitlab.ProjectReposityStorage, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceGetRepositoryStorageCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceGetRepositoryStorageCall) Do(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.ProjectReposityStorage, *gitlab.Response, error)) *MockProjectsServiceInterfaceGetRepositoryStorageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceGetRepositoryStorageCall) DoAndReturn(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.ProjectReposityStorage, *gitlab.Response, error)) *MockProjectsServiceInterfaceGetRepositoryStorageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListProjectForks mocks base method.
func (m *MockProjectsServiceInterface) ListProjectForks(pid any, opt *gitlab.ListProjectsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListProjectForks", varargs...)
	ret0, _ := ret[0].([]*gitlab.Project)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListProjectForks indicates an expected call of ListProjectForks.
func (mr *MockProjectsServiceInterfaceMockRecorder) ListProjectForks(pid, opt any, options ...any) *MockProjectsServiceInterfaceListProjectForksCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListProjectForks", reflect.TypeOf((*MockProjectsServiceInterface)(nil).ListProjectForks), varargs...)
	return &MockProjectsServiceInterfaceListProjectForksCall{Call: call}
}

// MockProjectsServiceInterfaceListProjectForksCall wrap *gomock.Call
type MockProjectsServiceInterfaceListProjectForksCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceListProjectForksCall) Return(arg0 []*gitlab.Project, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceListProjectForksCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceListProjectForksCall) Do(f func(any, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceListProjectForksCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceListProjectForksCall) DoAndReturn(f func(any, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceListProjectForksCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListProjectHooks mocks base method.
func (m *MockProjectsServiceInterface) ListProjectHooks(pid any, opt *gitlab.ListProjectHooksOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectHook, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListProjectHooks", varargs...)
	ret0, _ := ret[0].([]*gitlab.ProjectHook)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListProjectHooks indicates an expected call of ListProjectHooks.
func (mr *MockProjectsServiceInterfaceMockRecorder) ListProjectHooks(pid, opt any, options ...any) *MockProjectsServiceInterfaceListProjectHooksCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListProjectHooks", reflect.TypeOf((*MockProjectsServiceInterface)(nil).ListProjectHooks), varargs...)
	return &MockProjectsServiceInterfaceListProjectHooksCall{Call: call}
}

// MockProjectsServiceInterfaceListProjectHooksCall wrap *gomock.Call
type MockProjectsServiceInterfaceListProjectHooksCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceListProjectHooksCall) Return(arg0 []*gitlab.ProjectHook, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceListProjectHooksCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceListProjectHooksCall) Do(f func(any, *gitlab.ListProjectHooksOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectHook, *gitlab.Response, error)) *MockProjectsServiceInterfaceListProjectHooksCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceListProjectHooksCall) DoAndReturn(f func(any, *gitlab.ListProjectHooksOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectHook, *gitlab.Response, error)) *MockProjectsServiceInterfaceListProjectHooksCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListProjects mocks base method.
func (m *MockProjectsServiceInterface) ListProjects(opt *gitlab.ListProjectsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListProjects", varargs...)
	ret0, _ := ret[0].([]*gitlab.Project)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListProjects indicates an expected call of ListProjects.
func (mr *MockProjectsServiceInterfaceMockRecorder) ListProjects(opt any, options ...any) *MockProjectsServiceInterfaceListProjectsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListProjects", reflect.TypeOf((*MockProjectsServiceInterface)(nil).ListProjects), varargs...)
	return &MockProjectsServiceInterfaceListProjectsCall{Call: call}
}

// MockProjectsServiceInterfaceListProjectsCall wrap *gomock.Call
type MockProjectsServiceInterfaceListProjectsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceListProjectsCall) Return(arg0 []*gitlab.Project, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceListProjectsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceListProjectsCall) Do(f func(*gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceListProjectsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceListProjectsCall) DoAndReturn(f func(*gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceListProjectsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListProjectsGroups mocks base method.
func (m *MockProjectsServiceInterface) ListProjectsGroups(pid any, opt *gitlab.ListProjectGroupOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectGroup, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListProjectsGroups", varargs...)
	ret0, _ := ret[0].([]*gitlab.ProjectGroup)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListProjectsGroups indicates an expected call of ListProjectsGroups.
func (mr *MockProjectsServiceInterfaceMockRecorder) ListProjectsGroups(pid, opt any, options ...any) *MockProjectsServiceInterfaceListProjectsGroupsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListProjectsGroups", reflect.TypeOf((*MockProjectsServiceInterface)(nil).ListProjectsGroups), varargs...)
	return &MockProjectsServiceInterfaceListProjectsGroupsCall{Call: call}
}

// MockProjectsServiceInterfaceListProjectsGroupsCall wrap *gomock.Call
type MockProjectsServiceInterfaceListProjectsGroupsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceListProjectsGroupsCall) Return(arg0 []*gitlab.ProjectGroup, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceListProjectsGroupsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceListProjectsGroupsCall) Do(f func(any, *gitlab.ListProjectGroupOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectGroup, *gitlab.Response, error)) *MockProjectsServiceInterfaceListProjectsGroupsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceListProjectsGroupsCall) DoAndReturn(f func(any, *gitlab.ListProjectGroupOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectGroup, *gitlab.Response, error)) *MockProjectsServiceInterfaceListProjectsGroupsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListProjectsInvitedGroups mocks base method.
func (m *MockProjectsServiceInterface) ListProjectsInvitedGroups(pid any, opt *gitlab.ListProjectInvidedGroupOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectGroup, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListProjectsInvitedGroups", varargs...)
	ret0, _ := ret[0].([]*gitlab.ProjectGroup)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListProjectsInvitedGroups indicates an expected call of ListProjectsInvitedGroups.
func (mr *MockProjectsServiceInterfaceMockRecorder) ListProjectsInvitedGroups(pid, opt any, options ...any) *MockProjectsServiceInterfaceListProjectsInvitedGroupsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListProjectsInvitedGroups", reflect.TypeOf((*MockProjectsServiceInterface)(nil).ListProjectsInvitedGroups), varargs...)
	return &MockProjectsServiceInterfaceListProjectsInvitedGroupsCall{Call: call}
}

// MockProjectsServiceInterfaceListProjectsInvitedGroupsCall wrap *gomock.Call
type MockProjectsServiceInterfaceListProjectsInvitedGroupsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceListProjectsInvitedGroupsCall) Return(arg0 []*gitlab.ProjectGroup, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceListProjectsInvitedGroupsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceListProjectsInvitedGroupsCall) Do(f func(any, *gitlab.ListProjectInvidedGroupOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectGroup, *gitlab.Response, error)) *MockProjectsServiceInterfaceListProjectsInvitedGroupsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceListProjectsInvitedGroupsCall) DoAndReturn(f func(any, *gitlab.ListProjectInvidedGroupOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectGroup, *gitlab.Response, error)) *MockProjectsServiceInterfaceListProjectsInvitedGroupsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListProjectsUsers mocks base method.
func (m *MockProjectsServiceInterface) ListProjectsUsers(pid any, opt *gitlab.ListProjectUserOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectUser, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListProjectsUsers", varargs...)
	ret0, _ := ret[0].([]*gitlab.ProjectUser)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListProjectsUsers indicates an expected call of ListProjectsUsers.
func (mr *MockProjectsServiceInterfaceMockRecorder) ListProjectsUsers(pid, opt any, options ...any) *MockProjectsServiceInterfaceListProjectsUsersCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListProjectsUsers", reflect.TypeOf((*MockProjectsServiceInterface)(nil).ListProjectsUsers), varargs...)
	return &MockProjectsServiceInterfaceListProjectsUsersCall{Call: call}
}

// MockProjectsServiceInterfaceListProjectsUsersCall wrap *gomock.Call
type MockProjectsServiceInterfaceListProjectsUsersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceListProjectsUsersCall) Return(arg0 []*gitlab.ProjectUser, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceListProjectsUsersCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceListProjectsUsersCall) Do(f func(any, *gitlab.ListProjectUserOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectUser, *gitlab.Response, error)) *MockProjectsServiceInterfaceListProjectsUsersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceListProjectsUsersCall) DoAndReturn(f func(any, *gitlab.ListProjectUserOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectUser, *gitlab.Response, error)) *MockProjectsServiceInterfaceListProjectsUsersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListUserContributedProjects mocks base method.
func (m *MockProjectsServiceInterface) ListUserContributedProjects(uid any, opt *gitlab.ListProjectsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{uid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListUserContributedProjects", varargs...)
	ret0, _ := ret[0].([]*gitlab.Project)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListUserContributedProjects indicates an expected call of ListUserContributedProjects.
func (mr *MockProjectsServiceInterfaceMockRecorder) ListUserContributedProjects(uid, opt any, options ...any) *MockProjectsServiceInterfaceListUserContributedProjectsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{uid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListUserContributedProjects", reflect.TypeOf((*MockProjectsServiceInterface)(nil).ListUserContributedProjects), varargs...)
	return &MockProjectsServiceInterfaceListUserContributedProjectsCall{Call: call}
}

// MockProjectsServiceInterfaceListUserContributedProjectsCall wrap *gomock.Call
type MockProjectsServiceInterfaceListUserContributedProjectsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceListUserContributedProjectsCall) Return(arg0 []*gitlab.Project, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceListUserContributedProjectsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceListUserContributedProjectsCall) Do(f func(any, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceListUserContributedProjectsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceListUserContributedProjectsCall) DoAndReturn(f func(any, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceListUserContributedProjectsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListUserProjects mocks base method.
func (m *MockProjectsServiceInterface) ListUserProjects(uid any, opt *gitlab.ListProjectsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{uid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListUserProjects", varargs...)
	ret0, _ := ret[0].([]*gitlab.Project)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListUserProjects indicates an expected call of ListUserProjects.
func (mr *MockProjectsServiceInterfaceMockRecorder) ListUserProjects(uid, opt any, options ...any) *MockProjectsServiceInterfaceListUserProjectsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{uid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListUserProjects", reflect.TypeOf((*MockProjectsServiceInterface)(nil).ListUserProjects), varargs...)
	return &MockProjectsServiceInterfaceListUserProjectsCall{Call: call}
}

// MockProjectsServiceInterfaceListUserProjectsCall wrap *gomock.Call
type MockProjectsServiceInterfaceListUserProjectsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceListUserProjectsCall) Return(arg0 []*gitlab.Project, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceListUserProjectsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceListUserProjectsCall) Do(f func(any, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceListUserProjectsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceListUserProjectsCall) DoAndReturn(f func(any, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceListUserProjectsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListUserStarredProjects mocks base method.
func (m *MockProjectsServiceInterface) ListUserStarredProjects(uid any, opt *gitlab.ListProjectsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{uid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListUserStarredProjects", varargs...)
	ret0, _ := ret[0].([]*gitlab.Project)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListUserStarredProjects indicates an expected call of ListUserStarredProjects.
func (mr *MockProjectsServiceInterfaceMockRecorder) ListUserStarredProjects(uid, opt any, options ...any) *MockProjectsServiceInterfaceListUserStarredProjectsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{uid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListUserStarredProjects", reflect.TypeOf((*MockProjectsServiceInterface)(nil).ListUserStarredProjects), varargs...)
	return &MockProjectsServiceInterfaceListUserStarredProjectsCall{Call: call}
}

// MockProjectsServiceInterfaceListUserStarredProjectsCall wrap *gomock.Call
type MockProjectsServiceInterfaceListUserStarredProjectsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceListUserStarredProjectsCall) Return(arg0 []*gitlab.Project, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceListUserStarredProjectsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceListUserStarredProjectsCall) Do(f func(any, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceListUserStarredProjectsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceListUserStarredProjectsCall) DoAndReturn(f func(any, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceListUserStarredProjectsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetProjectCustomHeader mocks base method.
func (m *MockProjectsServiceInterface) SetProjectCustomHeader(pid any, hook int, key string, opt *gitlab.SetHookCustomHeaderOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, hook, key, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SetProjectCustomHeader", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SetProjectCustomHeader indicates an expected call of SetProjectCustomHeader.
func (mr *MockProjectsServiceInterfaceMockRecorder) SetProjectCustomHeader(pid, hook, key, opt any, options ...any) *MockProjectsServiceInterfaceSetProjectCustomHeaderCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, hook, key, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetProjectCustomHeader", reflect.TypeOf((*MockProjectsServiceInterface)(nil).SetProjectCustomHeader), varargs...)
	return &MockProjectsServiceInterfaceSetProjectCustomHeaderCall{Call: call}
}

// MockProjectsServiceInterfaceSetProjectCustomHeaderCall wrap *gomock.Call
type MockProjectsServiceInterfaceSetProjectCustomHeaderCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceSetProjectCustomHeaderCall) Return(arg0 *gitlab.Response, arg1 error) *MockProjectsServiceInterfaceSetProjectCustomHeaderCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceSetProjectCustomHeaderCall) Do(f func(any, int, string, *gitlab.SetHookCustomHeaderOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceSetProjectCustomHeaderCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceSetProjectCustomHeaderCall) DoAndReturn(f func(any, int, string, *gitlab.SetHookCustomHeaderOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceSetProjectCustomHeaderCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ShareProjectWithGroup mocks base method.
func (m *MockProjectsServiceInterface) ShareProjectWithGroup(pid any, opt *gitlab.ShareWithGroupOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ShareProjectWithGroup", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ShareProjectWithGroup indicates an expected call of ShareProjectWithGroup.
func (mr *MockProjectsServiceInterfaceMockRecorder) ShareProjectWithGroup(pid, opt any, options ...any) *MockProjectsServiceInterfaceShareProjectWithGroupCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ShareProjectWithGroup", reflect.TypeOf((*MockProjectsServiceInterface)(nil).ShareProjectWithGroup), varargs...)
	return &MockProjectsServiceInterfaceShareProjectWithGroupCall{Call: call}
}

// MockProjectsServiceInterfaceShareProjectWithGroupCall wrap *gomock.Call
type MockProjectsServiceInterfaceShareProjectWithGroupCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceShareProjectWithGroupCall) Return(arg0 *gitlab.Response, arg1 error) *MockProjectsServiceInterfaceShareProjectWithGroupCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceShareProjectWithGroupCall) Do(f func(any, *gitlab.ShareWithGroupOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceShareProjectWithGroupCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceShareProjectWithGroupCall) DoAndReturn(f func(any, *gitlab.ShareWithGroupOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceShareProjectWithGroupCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StarProject mocks base method.
func (m *MockProjectsServiceInterface) StarProject(pid any, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "StarProject", varargs...)
	ret0, _ := ret[0].(*gitlab.Project)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// StarProject indicates an expected call of StarProject.
func (mr *MockProjectsServiceInterfaceMockRecorder) StarProject(pid any, options ...any) *MockProjectsServiceInterfaceStarProjectCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StarProject", reflect.TypeOf((*MockProjectsServiceInterface)(nil).StarProject), varargs...)
	return &MockProjectsServiceInterfaceStarProjectCall{Call: call}
}

// MockProjectsServiceInterfaceStarProjectCall wrap *gomock.Call
type MockProjectsServiceInterfaceStarProjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceStarProjectCall) Return(arg0 *gitlab.Project, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceStarProjectCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceStarProjectCall) Do(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceStarProjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceStarProjectCall) DoAndReturn(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceStarProjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StartHousekeepingProject mocks base method.
func (m *MockProjectsServiceInterface) StartHousekeepingProject(pid any, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "StartHousekeepingProject", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StartHousekeepingProject indicates an expected call of StartHousekeepingProject.
func (mr *MockProjectsServiceInterfaceMockRecorder) StartHousekeepingProject(pid any, options ...any) *MockProjectsServiceInterfaceStartHousekeepingProjectCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartHousekeepingProject", reflect.TypeOf((*MockProjectsServiceInterface)(nil).StartHousekeepingProject), varargs...)
	return &MockProjectsServiceInterfaceStartHousekeepingProjectCall{Call: call}
}

// MockProjectsServiceInterfaceStartHousekeepingProjectCall wrap *gomock.Call
type MockProjectsServiceInterfaceStartHousekeepingProjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceStartHousekeepingProjectCall) Return(arg0 *gitlab.Response, arg1 error) *MockProjectsServiceInterfaceStartHousekeepingProjectCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceStartHousekeepingProjectCall) Do(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceStartHousekeepingProjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceStartHousekeepingProjectCall) DoAndReturn(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceStartHousekeepingProjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StartMirroringProject mocks base method.
func (m *MockProjectsServiceInterface) StartMirroringProject(pid any, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "StartMirroringProject", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StartMirroringProject indicates an expected call of StartMirroringProject.
func (mr *MockProjectsServiceInterfaceMockRecorder) StartMirroringProject(pid any, options ...any) *MockProjectsServiceInterfaceStartMirroringProjectCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartMirroringProject", reflect.TypeOf((*MockProjectsServiceInterface)(nil).StartMirroringProject), varargs...)
	return &MockProjectsServiceInterfaceStartMirroringProjectCall{Call: call}
}

// MockProjectsServiceInterfaceStartMirroringProjectCall wrap *gomock.Call
type MockProjectsServiceInterfaceStartMirroringProjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceStartMirroringProjectCall) Return(arg0 *gitlab.Response, arg1 error) *MockProjectsServiceInterfaceStartMirroringProjectCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceStartMirroringProjectCall) Do(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceStartMirroringProjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceStartMirroringProjectCall) DoAndReturn(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceStartMirroringProjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TransferProject mocks base method.
func (m *MockProjectsServiceInterface) TransferProject(pid any, opt *gitlab.TransferProjectOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TransferProject", varargs...)
	ret0, _ := ret[0].(*gitlab.Project)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// TransferProject indicates an expected call of TransferProject.
func (mr *MockProjectsServiceInterfaceMockRecorder) TransferProject(pid, opt any, options ...any) *MockProjectsServiceInterfaceTransferProjectCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TransferProject", reflect.TypeOf((*MockProjectsServiceInterface)(nil).TransferProject), varargs...)
	return &MockProjectsServiceInterfaceTransferProjectCall{Call: call}
}

// MockProjectsServiceInterfaceTransferProjectCall wrap *gomock.Call
type MockProjectsServiceInterfaceTransferProjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceTransferProjectCall) Return(arg0 *gitlab.Project, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceTransferProjectCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceTransferProjectCall) Do(f func(any, *gitlab.TransferProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceTransferProjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceTransferProjectCall) DoAndReturn(f func(any, *gitlab.TransferProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceTransferProjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TriggerTestProjectHook mocks base method.
func (m *MockProjectsServiceInterface) TriggerTestProjectHook(pid any, hook int, event gitlab.ProjectHookEvent, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, hook, event}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TriggerTestProjectHook", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TriggerTestProjectHook indicates an expected call of TriggerTestProjectHook.
func (mr *MockProjectsServiceInterfaceMockRecorder) TriggerTestProjectHook(pid, hook, event any, options ...any) *MockProjectsServiceInterfaceTriggerTestProjectHookCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, hook, event}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TriggerTestProjectHook", reflect.TypeOf((*MockProjectsServiceInterface)(nil).TriggerTestProjectHook), varargs...)
	return &MockProjectsServiceInterfaceTriggerTestProjectHookCall{Call: call}
}

// MockProjectsServiceInterfaceTriggerTestProjectHookCall wrap *gomock.Call
type MockProjectsServiceInterfaceTriggerTestProjectHookCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceTriggerTestProjectHookCall) Return(arg0 *gitlab.Response, arg1 error) *MockProjectsServiceInterfaceTriggerTestProjectHookCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceTriggerTestProjectHookCall) Do(f func(any, int, gitlab.ProjectHookEvent, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceTriggerTestProjectHookCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceTriggerTestProjectHookCall) DoAndReturn(f func(any, int, gitlab.ProjectHookEvent, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockProjectsServiceInterfaceTriggerTestProjectHookCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnarchiveProject mocks base method.
func (m *MockProjectsServiceInterface) UnarchiveProject(pid any, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UnarchiveProject", varargs...)
	ret0, _ := ret[0].(*gitlab.Project)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// UnarchiveProject indicates an expected call of UnarchiveProject.
func (mr *MockProjectsServiceInterfaceMockRecorder) UnarchiveProject(pid any, options ...any) *MockProjectsServiceInterfaceUnarchiveProjectCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnarchiveProject", reflect.TypeOf((*MockProjectsServiceInterface)(nil).UnarchiveProject), varargs...)
	return &MockProjectsServiceInterfaceUnarchiveProjectCall{Call: call}
}

// MockProjectsServiceInterfaceUnarchiveProjectCall wrap *gomock.Call
type MockProjectsServiceInterfaceUnarchiveProjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceUnarchiveProjectCall) Return(arg0 *gitlab.Project, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceUnarchiveProjectCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceUnarchiveProjectCall) Do(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceUnarchiveProjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceUnarchiveProjectCall) DoAndReturn(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceUnarchiveProjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnstarProject mocks base method.
func (m *MockProjectsServiceInterface) UnstarProject(pid any, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UnstarProject", varargs...)
	ret0, _ := ret[0].(*gitlab.Project)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// UnstarProject indicates an expected call of UnstarProject.
func (mr *MockProjectsServiceInterfaceMockRecorder) UnstarProject(pid any, options ...any) *MockProjectsServiceInterfaceUnstarProjectCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnstarProject", reflect.TypeOf((*MockProjectsServiceInterface)(nil).UnstarProject), varargs...)
	return &MockProjectsServiceInterfaceUnstarProjectCall{Call: call}
}

// MockProjectsServiceInterfaceUnstarProjectCall wrap *gomock.Call
type MockProjectsServiceInterfaceUnstarProjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceUnstarProjectCall) Return(arg0 *gitlab.Project, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceUnstarProjectCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceUnstarProjectCall) Do(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceUnstarProjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceUnstarProjectCall) DoAndReturn(f func(any, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceUnstarProjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateProjectApprovalRule mocks base method.
func (m *MockProjectsServiceInterface) UpdateProjectApprovalRule(pid any, approvalRule int, opt *gitlab.UpdateProjectLevelRuleOptions, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovalRule, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, approvalRule, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateProjectApprovalRule", varargs...)
	ret0, _ := ret[0].(*gitlab.ProjectApprovalRule)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// UpdateProjectApprovalRule indicates an expected call of UpdateProjectApprovalRule.
func (mr *MockProjectsServiceInterfaceMockRecorder) UpdateProjectApprovalRule(pid, approvalRule, opt any, options ...any) *MockProjectsServiceInterfaceUpdateProjectApprovalRuleCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, approvalRule, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateProjectApprovalRule", reflect.TypeOf((*MockProjectsServiceInterface)(nil).UpdateProjectApprovalRule), varargs...)
	return &MockProjectsServiceInterfaceUpdateProjectApprovalRuleCall{Call: call}
}

// MockProjectsServiceInterfaceUpdateProjectApprovalRuleCall wrap *gomock.Call
type MockProjectsServiceInterfaceUpdateProjectApprovalRuleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceUpdateProjectApprovalRuleCall) Return(arg0 *gitlab.ProjectApprovalRule, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceUpdateProjectApprovalRuleCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceUpdateProjectApprovalRuleCall) Do(f func(any, int, *gitlab.UpdateProjectLevelRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovalRule, *gitlab.Response, error)) *MockProjectsServiceInterfaceUpdateProjectApprovalRuleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceUpdateProjectApprovalRuleCall) DoAndReturn(f func(any, int, *gitlab.UpdateProjectLevelRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovalRule, *gitlab.Response, error)) *MockProjectsServiceInterfaceUpdateProjectApprovalRuleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UploadAvatar mocks base method.
func (m *MockProjectsServiceInterface) UploadAvatar(pid any, avatar io.Reader, filename string, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, avatar, filename}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UploadAvatar", varargs...)
	ret0, _ := ret[0].(*gitlab.Project)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// UploadAvatar indicates an expected call of UploadAvatar.
func (mr *MockProjectsServiceInterfaceMockRecorder) UploadAvatar(pid, avatar, filename any, options ...any) *MockProjectsServiceInterfaceUploadAvatarCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, avatar, filename}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UploadAvatar", reflect.TypeOf((*MockProjectsServiceInterface)(nil).UploadAvatar), varargs...)
	return &MockProjectsServiceInterfaceUploadAvatarCall{Call: call}
}

// MockProjectsServiceInterfaceUploadAvatarCall wrap *gomock.Call
type MockProjectsServiceInterfaceUploadAvatarCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockProjectsServiceInterfaceUploadAvatarCall) Return(arg0 *gitlab.Project, arg1 *gitlab.Response, arg2 error) *MockProjectsServiceInterfaceUploadAvatarCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockProjectsServiceInterfaceUploadAvatarCall) Do(f func(any, io.Reader, string, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceUploadAvatarCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockProjectsServiceInterfaceUploadAvatarCall) DoAndReturn(f func(any, io.Reader, string, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *MockProjectsServiceInterfaceUploadAvatarCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
