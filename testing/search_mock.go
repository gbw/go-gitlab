// Code generated by MockGen. DO NOT EDIT.
// Source: gitlab.com/gitlab-org/api/client-go (interfaces: SearchServiceInterface)
//
// Generated by this command:
//
//	mockgen -typed -destination=search_mock.go -package=testing gitlab.com/gitlab-org/api/client-go SearchServiceInterface
//

// Package testing is a generated GoMock package.
package testing

import (
	reflect "reflect"

	gitlab "gitlab.com/gitlab-org/api/client-go"
	gomock "go.uber.org/mock/gomock"
)

// MockSearchServiceInterface is a mock of SearchServiceInterface interface.
type MockSearchServiceInterface struct {
	ctrl     *gomock.Controller
	recorder *MockSearchServiceInterfaceMockRecorder
	isgomock struct{}
}

// MockSearchServiceInterfaceMockRecorder is the mock recorder for MockSearchServiceInterface.
type MockSearchServiceInterfaceMockRecorder struct {
	mock *MockSearchServiceInterface
}

// NewMockSearchServiceInterface creates a new mock instance.
func NewMockSearchServiceInterface(ctrl *gomock.Controller) *MockSearchServiceInterface {
	mock := &MockSearchServiceInterface{ctrl: ctrl}
	mock.recorder = &MockSearchServiceInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSearchServiceInterface) EXPECT() *MockSearchServiceInterfaceMockRecorder {
	return m.recorder
}

// Blobs mocks base method.
func (m *MockSearchServiceInterface) Blobs(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Blob, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Blobs", varargs...)
	ret0, _ := ret[0].([]*gitlab.Blob)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Blobs indicates an expected call of Blobs.
func (mr *MockSearchServiceInterfaceMockRecorder) Blobs(query, opt any, options ...any) *MockSearchServiceInterfaceBlobsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Blobs", reflect.TypeOf((*MockSearchServiceInterface)(nil).Blobs), varargs...)
	return &MockSearchServiceInterfaceBlobsCall{Call: call}
}

// MockSearchServiceInterfaceBlobsCall wrap *gomock.Call
type MockSearchServiceInterfaceBlobsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceBlobsCall) Return(arg0 []*gitlab.Blob, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceBlobsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceBlobsCall) Do(f func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Blob, *gitlab.Response, error)) *MockSearchServiceInterfaceBlobsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceBlobsCall) DoAndReturn(f func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Blob, *gitlab.Response, error)) *MockSearchServiceInterfaceBlobsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BlobsByGroup mocks base method.
func (m *MockSearchServiceInterface) BlobsByGroup(gid any, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Blob, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{gid, query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BlobsByGroup", varargs...)
	ret0, _ := ret[0].([]*gitlab.Blob)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// BlobsByGroup indicates an expected call of BlobsByGroup.
func (mr *MockSearchServiceInterfaceMockRecorder) BlobsByGroup(gid, query, opt any, options ...any) *MockSearchServiceInterfaceBlobsByGroupCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{gid, query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BlobsByGroup", reflect.TypeOf((*MockSearchServiceInterface)(nil).BlobsByGroup), varargs...)
	return &MockSearchServiceInterfaceBlobsByGroupCall{Call: call}
}

// MockSearchServiceInterfaceBlobsByGroupCall wrap *gomock.Call
type MockSearchServiceInterfaceBlobsByGroupCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceBlobsByGroupCall) Return(arg0 []*gitlab.Blob, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceBlobsByGroupCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceBlobsByGroupCall) Do(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Blob, *gitlab.Response, error)) *MockSearchServiceInterfaceBlobsByGroupCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceBlobsByGroupCall) DoAndReturn(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Blob, *gitlab.Response, error)) *MockSearchServiceInterfaceBlobsByGroupCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BlobsByProject mocks base method.
func (m *MockSearchServiceInterface) BlobsByProject(pid any, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Blob, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BlobsByProject", varargs...)
	ret0, _ := ret[0].([]*gitlab.Blob)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// BlobsByProject indicates an expected call of BlobsByProject.
func (mr *MockSearchServiceInterfaceMockRecorder) BlobsByProject(pid, query, opt any, options ...any) *MockSearchServiceInterfaceBlobsByProjectCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BlobsByProject", reflect.TypeOf((*MockSearchServiceInterface)(nil).BlobsByProject), varargs...)
	return &MockSearchServiceInterfaceBlobsByProjectCall{Call: call}
}

// MockSearchServiceInterfaceBlobsByProjectCall wrap *gomock.Call
type MockSearchServiceInterfaceBlobsByProjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceBlobsByProjectCall) Return(arg0 []*gitlab.Blob, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceBlobsByProjectCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceBlobsByProjectCall) Do(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Blob, *gitlab.Response, error)) *MockSearchServiceInterfaceBlobsByProjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceBlobsByProjectCall) DoAndReturn(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Blob, *gitlab.Response, error)) *MockSearchServiceInterfaceBlobsByProjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Commits mocks base method.
func (m *MockSearchServiceInterface) Commits(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Commits", varargs...)
	ret0, _ := ret[0].([]*gitlab.Commit)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Commits indicates an expected call of Commits.
func (mr *MockSearchServiceInterfaceMockRecorder) Commits(query, opt any, options ...any) *MockSearchServiceInterfaceCommitsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commits", reflect.TypeOf((*MockSearchServiceInterface)(nil).Commits), varargs...)
	return &MockSearchServiceInterfaceCommitsCall{Call: call}
}

// MockSearchServiceInterfaceCommitsCall wrap *gomock.Call
type MockSearchServiceInterfaceCommitsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceCommitsCall) Return(arg0 []*gitlab.Commit, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceCommitsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceCommitsCall) Do(f func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error)) *MockSearchServiceInterfaceCommitsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceCommitsCall) DoAndReturn(f func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error)) *MockSearchServiceInterfaceCommitsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CommitsByGroup mocks base method.
func (m *MockSearchServiceInterface) CommitsByGroup(gid any, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{gid, query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CommitsByGroup", varargs...)
	ret0, _ := ret[0].([]*gitlab.Commit)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CommitsByGroup indicates an expected call of CommitsByGroup.
func (mr *MockSearchServiceInterfaceMockRecorder) CommitsByGroup(gid, query, opt any, options ...any) *MockSearchServiceInterfaceCommitsByGroupCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{gid, query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CommitsByGroup", reflect.TypeOf((*MockSearchServiceInterface)(nil).CommitsByGroup), varargs...)
	return &MockSearchServiceInterfaceCommitsByGroupCall{Call: call}
}

// MockSearchServiceInterfaceCommitsByGroupCall wrap *gomock.Call
type MockSearchServiceInterfaceCommitsByGroupCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceCommitsByGroupCall) Return(arg0 []*gitlab.Commit, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceCommitsByGroupCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceCommitsByGroupCall) Do(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error)) *MockSearchServiceInterfaceCommitsByGroupCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceCommitsByGroupCall) DoAndReturn(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error)) *MockSearchServiceInterfaceCommitsByGroupCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CommitsByProject mocks base method.
func (m *MockSearchServiceInterface) CommitsByProject(pid any, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CommitsByProject", varargs...)
	ret0, _ := ret[0].([]*gitlab.Commit)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CommitsByProject indicates an expected call of CommitsByProject.
func (mr *MockSearchServiceInterfaceMockRecorder) CommitsByProject(pid, query, opt any, options ...any) *MockSearchServiceInterfaceCommitsByProjectCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CommitsByProject", reflect.TypeOf((*MockSearchServiceInterface)(nil).CommitsByProject), varargs...)
	return &MockSearchServiceInterfaceCommitsByProjectCall{Call: call}
}

// MockSearchServiceInterfaceCommitsByProjectCall wrap *gomock.Call
type MockSearchServiceInterfaceCommitsByProjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceCommitsByProjectCall) Return(arg0 []*gitlab.Commit, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceCommitsByProjectCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceCommitsByProjectCall) Do(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error)) *MockSearchServiceInterfaceCommitsByProjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceCommitsByProjectCall) DoAndReturn(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error)) *MockSearchServiceInterfaceCommitsByProjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Issues mocks base method.
func (m *MockSearchServiceInterface) Issues(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Issues", varargs...)
	ret0, _ := ret[0].([]*gitlab.Issue)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Issues indicates an expected call of Issues.
func (mr *MockSearchServiceInterfaceMockRecorder) Issues(query, opt any, options ...any) *MockSearchServiceInterfaceIssuesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Issues", reflect.TypeOf((*MockSearchServiceInterface)(nil).Issues), varargs...)
	return &MockSearchServiceInterfaceIssuesCall{Call: call}
}

// MockSearchServiceInterfaceIssuesCall wrap *gomock.Call
type MockSearchServiceInterfaceIssuesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceIssuesCall) Return(arg0 []*gitlab.Issue, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceIssuesCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceIssuesCall) Do(f func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)) *MockSearchServiceInterfaceIssuesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceIssuesCall) DoAndReturn(f func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)) *MockSearchServiceInterfaceIssuesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IssuesByGroup mocks base method.
func (m *MockSearchServiceInterface) IssuesByGroup(gid any, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{gid, query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "IssuesByGroup", varargs...)
	ret0, _ := ret[0].([]*gitlab.Issue)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// IssuesByGroup indicates an expected call of IssuesByGroup.
func (mr *MockSearchServiceInterfaceMockRecorder) IssuesByGroup(gid, query, opt any, options ...any) *MockSearchServiceInterfaceIssuesByGroupCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{gid, query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IssuesByGroup", reflect.TypeOf((*MockSearchServiceInterface)(nil).IssuesByGroup), varargs...)
	return &MockSearchServiceInterfaceIssuesByGroupCall{Call: call}
}

// MockSearchServiceInterfaceIssuesByGroupCall wrap *gomock.Call
type MockSearchServiceInterfaceIssuesByGroupCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceIssuesByGroupCall) Return(arg0 []*gitlab.Issue, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceIssuesByGroupCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceIssuesByGroupCall) Do(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)) *MockSearchServiceInterfaceIssuesByGroupCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceIssuesByGroupCall) DoAndReturn(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)) *MockSearchServiceInterfaceIssuesByGroupCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IssuesByProject mocks base method.
func (m *MockSearchServiceInterface) IssuesByProject(pid any, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "IssuesByProject", varargs...)
	ret0, _ := ret[0].([]*gitlab.Issue)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// IssuesByProject indicates an expected call of IssuesByProject.
func (mr *MockSearchServiceInterfaceMockRecorder) IssuesByProject(pid, query, opt any, options ...any) *MockSearchServiceInterfaceIssuesByProjectCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IssuesByProject", reflect.TypeOf((*MockSearchServiceInterface)(nil).IssuesByProject), varargs...)
	return &MockSearchServiceInterfaceIssuesByProjectCall{Call: call}
}

// MockSearchServiceInterfaceIssuesByProjectCall wrap *gomock.Call
type MockSearchServiceInterfaceIssuesByProjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceIssuesByProjectCall) Return(arg0 []*gitlab.Issue, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceIssuesByProjectCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceIssuesByProjectCall) Do(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)) *MockSearchServiceInterfaceIssuesByProjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceIssuesByProjectCall) DoAndReturn(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)) *MockSearchServiceInterfaceIssuesByProjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MergeRequests mocks base method.
func (m *MockSearchServiceInterface) MergeRequests(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequest, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MergeRequests", varargs...)
	ret0, _ := ret[0].([]*gitlab.MergeRequest)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MergeRequests indicates an expected call of MergeRequests.
func (mr *MockSearchServiceInterfaceMockRecorder) MergeRequests(query, opt any, options ...any) *MockSearchServiceInterfaceMergeRequestsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MergeRequests", reflect.TypeOf((*MockSearchServiceInterface)(nil).MergeRequests), varargs...)
	return &MockSearchServiceInterfaceMergeRequestsCall{Call: call}
}

// MockSearchServiceInterfaceMergeRequestsCall wrap *gomock.Call
type MockSearchServiceInterfaceMergeRequestsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceMergeRequestsCall) Return(arg0 []*gitlab.MergeRequest, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceMergeRequestsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceMergeRequestsCall) Do(f func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequest, *gitlab.Response, error)) *MockSearchServiceInterfaceMergeRequestsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceMergeRequestsCall) DoAndReturn(f func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequest, *gitlab.Response, error)) *MockSearchServiceInterfaceMergeRequestsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MergeRequestsByGroup mocks base method.
func (m *MockSearchServiceInterface) MergeRequestsByGroup(gid any, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequest, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{gid, query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MergeRequestsByGroup", varargs...)
	ret0, _ := ret[0].([]*gitlab.MergeRequest)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MergeRequestsByGroup indicates an expected call of MergeRequestsByGroup.
func (mr *MockSearchServiceInterfaceMockRecorder) MergeRequestsByGroup(gid, query, opt any, options ...any) *MockSearchServiceInterfaceMergeRequestsByGroupCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{gid, query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MergeRequestsByGroup", reflect.TypeOf((*MockSearchServiceInterface)(nil).MergeRequestsByGroup), varargs...)
	return &MockSearchServiceInterfaceMergeRequestsByGroupCall{Call: call}
}

// MockSearchServiceInterfaceMergeRequestsByGroupCall wrap *gomock.Call
type MockSearchServiceInterfaceMergeRequestsByGroupCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceMergeRequestsByGroupCall) Return(arg0 []*gitlab.MergeRequest, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceMergeRequestsByGroupCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceMergeRequestsByGroupCall) Do(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequest, *gitlab.Response, error)) *MockSearchServiceInterfaceMergeRequestsByGroupCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceMergeRequestsByGroupCall) DoAndReturn(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequest, *gitlab.Response, error)) *MockSearchServiceInterfaceMergeRequestsByGroupCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MergeRequestsByProject mocks base method.
func (m *MockSearchServiceInterface) MergeRequestsByProject(pid any, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequest, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MergeRequestsByProject", varargs...)
	ret0, _ := ret[0].([]*gitlab.MergeRequest)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MergeRequestsByProject indicates an expected call of MergeRequestsByProject.
func (mr *MockSearchServiceInterfaceMockRecorder) MergeRequestsByProject(pid, query, opt any, options ...any) *MockSearchServiceInterfaceMergeRequestsByProjectCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MergeRequestsByProject", reflect.TypeOf((*MockSearchServiceInterface)(nil).MergeRequestsByProject), varargs...)
	return &MockSearchServiceInterfaceMergeRequestsByProjectCall{Call: call}
}

// MockSearchServiceInterfaceMergeRequestsByProjectCall wrap *gomock.Call
type MockSearchServiceInterfaceMergeRequestsByProjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceMergeRequestsByProjectCall) Return(arg0 []*gitlab.MergeRequest, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceMergeRequestsByProjectCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceMergeRequestsByProjectCall) Do(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequest, *gitlab.Response, error)) *MockSearchServiceInterfaceMergeRequestsByProjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceMergeRequestsByProjectCall) DoAndReturn(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequest, *gitlab.Response, error)) *MockSearchServiceInterfaceMergeRequestsByProjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Milestones mocks base method.
func (m *MockSearchServiceInterface) Milestones(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Milestone, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Milestones", varargs...)
	ret0, _ := ret[0].([]*gitlab.Milestone)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Milestones indicates an expected call of Milestones.
func (mr *MockSearchServiceInterfaceMockRecorder) Milestones(query, opt any, options ...any) *MockSearchServiceInterfaceMilestonesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Milestones", reflect.TypeOf((*MockSearchServiceInterface)(nil).Milestones), varargs...)
	return &MockSearchServiceInterfaceMilestonesCall{Call: call}
}

// MockSearchServiceInterfaceMilestonesCall wrap *gomock.Call
type MockSearchServiceInterfaceMilestonesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceMilestonesCall) Return(arg0 []*gitlab.Milestone, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceMilestonesCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceMilestonesCall) Do(f func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Milestone, *gitlab.Response, error)) *MockSearchServiceInterfaceMilestonesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceMilestonesCall) DoAndReturn(f func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Milestone, *gitlab.Response, error)) *MockSearchServiceInterfaceMilestonesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MilestonesByGroup mocks base method.
func (m *MockSearchServiceInterface) MilestonesByGroup(gid any, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Milestone, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{gid, query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MilestonesByGroup", varargs...)
	ret0, _ := ret[0].([]*gitlab.Milestone)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MilestonesByGroup indicates an expected call of MilestonesByGroup.
func (mr *MockSearchServiceInterfaceMockRecorder) MilestonesByGroup(gid, query, opt any, options ...any) *MockSearchServiceInterfaceMilestonesByGroupCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{gid, query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MilestonesByGroup", reflect.TypeOf((*MockSearchServiceInterface)(nil).MilestonesByGroup), varargs...)
	return &MockSearchServiceInterfaceMilestonesByGroupCall{Call: call}
}

// MockSearchServiceInterfaceMilestonesByGroupCall wrap *gomock.Call
type MockSearchServiceInterfaceMilestonesByGroupCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceMilestonesByGroupCall) Return(arg0 []*gitlab.Milestone, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceMilestonesByGroupCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceMilestonesByGroupCall) Do(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Milestone, *gitlab.Response, error)) *MockSearchServiceInterfaceMilestonesByGroupCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceMilestonesByGroupCall) DoAndReturn(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Milestone, *gitlab.Response, error)) *MockSearchServiceInterfaceMilestonesByGroupCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MilestonesByProject mocks base method.
func (m *MockSearchServiceInterface) MilestonesByProject(pid any, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Milestone, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MilestonesByProject", varargs...)
	ret0, _ := ret[0].([]*gitlab.Milestone)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MilestonesByProject indicates an expected call of MilestonesByProject.
func (mr *MockSearchServiceInterfaceMockRecorder) MilestonesByProject(pid, query, opt any, options ...any) *MockSearchServiceInterfaceMilestonesByProjectCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MilestonesByProject", reflect.TypeOf((*MockSearchServiceInterface)(nil).MilestonesByProject), varargs...)
	return &MockSearchServiceInterfaceMilestonesByProjectCall{Call: call}
}

// MockSearchServiceInterfaceMilestonesByProjectCall wrap *gomock.Call
type MockSearchServiceInterfaceMilestonesByProjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceMilestonesByProjectCall) Return(arg0 []*gitlab.Milestone, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceMilestonesByProjectCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceMilestonesByProjectCall) Do(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Milestone, *gitlab.Response, error)) *MockSearchServiceInterfaceMilestonesByProjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceMilestonesByProjectCall) DoAndReturn(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Milestone, *gitlab.Response, error)) *MockSearchServiceInterfaceMilestonesByProjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NotesByProject mocks base method.
func (m *MockSearchServiceInterface) NotesByProject(pid any, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "NotesByProject", varargs...)
	ret0, _ := ret[0].([]*gitlab.Note)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// NotesByProject indicates an expected call of NotesByProject.
func (mr *MockSearchServiceInterfaceMockRecorder) NotesByProject(pid, query, opt any, options ...any) *MockSearchServiceInterfaceNotesByProjectCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NotesByProject", reflect.TypeOf((*MockSearchServiceInterface)(nil).NotesByProject), varargs...)
	return &MockSearchServiceInterfaceNotesByProjectCall{Call: call}
}

// MockSearchServiceInterfaceNotesByProjectCall wrap *gomock.Call
type MockSearchServiceInterfaceNotesByProjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceNotesByProjectCall) Return(arg0 []*gitlab.Note, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceNotesByProjectCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceNotesByProjectCall) Do(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error)) *MockSearchServiceInterfaceNotesByProjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceNotesByProjectCall) DoAndReturn(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error)) *MockSearchServiceInterfaceNotesByProjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Projects mocks base method.
func (m *MockSearchServiceInterface) Projects(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Projects", varargs...)
	ret0, _ := ret[0].([]*gitlab.Project)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Projects indicates an expected call of Projects.
func (mr *MockSearchServiceInterfaceMockRecorder) Projects(query, opt any, options ...any) *MockSearchServiceInterfaceProjectsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Projects", reflect.TypeOf((*MockSearchServiceInterface)(nil).Projects), varargs...)
	return &MockSearchServiceInterfaceProjectsCall{Call: call}
}

// MockSearchServiceInterfaceProjectsCall wrap *gomock.Call
type MockSearchServiceInterfaceProjectsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceProjectsCall) Return(arg0 []*gitlab.Project, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceProjectsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceProjectsCall) Do(f func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *MockSearchServiceInterfaceProjectsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceProjectsCall) DoAndReturn(f func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *MockSearchServiceInterfaceProjectsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ProjectsByGroup mocks base method.
func (m *MockSearchServiceInterface) ProjectsByGroup(gid any, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{gid, query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ProjectsByGroup", varargs...)
	ret0, _ := ret[0].([]*gitlab.Project)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ProjectsByGroup indicates an expected call of ProjectsByGroup.
func (mr *MockSearchServiceInterfaceMockRecorder) ProjectsByGroup(gid, query, opt any, options ...any) *MockSearchServiceInterfaceProjectsByGroupCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{gid, query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProjectsByGroup", reflect.TypeOf((*MockSearchServiceInterface)(nil).ProjectsByGroup), varargs...)
	return &MockSearchServiceInterfaceProjectsByGroupCall{Call: call}
}

// MockSearchServiceInterfaceProjectsByGroupCall wrap *gomock.Call
type MockSearchServiceInterfaceProjectsByGroupCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceProjectsByGroupCall) Return(arg0 []*gitlab.Project, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceProjectsByGroupCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceProjectsByGroupCall) Do(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *MockSearchServiceInterfaceProjectsByGroupCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceProjectsByGroupCall) DoAndReturn(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *MockSearchServiceInterfaceProjectsByGroupCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SnippetBlobs mocks base method.
func (m *MockSearchServiceInterface) SnippetBlobs(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Snippet, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SnippetBlobs", varargs...)
	ret0, _ := ret[0].([]*gitlab.Snippet)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// SnippetBlobs indicates an expected call of SnippetBlobs.
func (mr *MockSearchServiceInterfaceMockRecorder) SnippetBlobs(query, opt any, options ...any) *MockSearchServiceInterfaceSnippetBlobsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SnippetBlobs", reflect.TypeOf((*MockSearchServiceInterface)(nil).SnippetBlobs), varargs...)
	return &MockSearchServiceInterfaceSnippetBlobsCall{Call: call}
}

// MockSearchServiceInterfaceSnippetBlobsCall wrap *gomock.Call
type MockSearchServiceInterfaceSnippetBlobsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceSnippetBlobsCall) Return(arg0 []*gitlab.Snippet, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceSnippetBlobsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceSnippetBlobsCall) Do(f func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Snippet, *gitlab.Response, error)) *MockSearchServiceInterfaceSnippetBlobsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceSnippetBlobsCall) DoAndReturn(f func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Snippet, *gitlab.Response, error)) *MockSearchServiceInterfaceSnippetBlobsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SnippetTitles mocks base method.
func (m *MockSearchServiceInterface) SnippetTitles(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Snippet, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SnippetTitles", varargs...)
	ret0, _ := ret[0].([]*gitlab.Snippet)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// SnippetTitles indicates an expected call of SnippetTitles.
func (mr *MockSearchServiceInterfaceMockRecorder) SnippetTitles(query, opt any, options ...any) *MockSearchServiceInterfaceSnippetTitlesCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SnippetTitles", reflect.TypeOf((*MockSearchServiceInterface)(nil).SnippetTitles), varargs...)
	return &MockSearchServiceInterfaceSnippetTitlesCall{Call: call}
}

// MockSearchServiceInterfaceSnippetTitlesCall wrap *gomock.Call
type MockSearchServiceInterfaceSnippetTitlesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceSnippetTitlesCall) Return(arg0 []*gitlab.Snippet, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceSnippetTitlesCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceSnippetTitlesCall) Do(f func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Snippet, *gitlab.Response, error)) *MockSearchServiceInterfaceSnippetTitlesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceSnippetTitlesCall) DoAndReturn(f func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Snippet, *gitlab.Response, error)) *MockSearchServiceInterfaceSnippetTitlesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Users mocks base method.
func (m *MockSearchServiceInterface) Users(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Users", varargs...)
	ret0, _ := ret[0].([]*gitlab.User)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Users indicates an expected call of Users.
func (mr *MockSearchServiceInterfaceMockRecorder) Users(query, opt any, options ...any) *MockSearchServiceInterfaceUsersCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Users", reflect.TypeOf((*MockSearchServiceInterface)(nil).Users), varargs...)
	return &MockSearchServiceInterfaceUsersCall{Call: call}
}

// MockSearchServiceInterfaceUsersCall wrap *gomock.Call
type MockSearchServiceInterfaceUsersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceUsersCall) Return(arg0 []*gitlab.User, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceUsersCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceUsersCall) Do(f func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error)) *MockSearchServiceInterfaceUsersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceUsersCall) DoAndReturn(f func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error)) *MockSearchServiceInterfaceUsersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UsersByGroup mocks base method.
func (m *MockSearchServiceInterface) UsersByGroup(gid any, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{gid, query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UsersByGroup", varargs...)
	ret0, _ := ret[0].([]*gitlab.User)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// UsersByGroup indicates an expected call of UsersByGroup.
func (mr *MockSearchServiceInterfaceMockRecorder) UsersByGroup(gid, query, opt any, options ...any) *MockSearchServiceInterfaceUsersByGroupCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{gid, query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UsersByGroup", reflect.TypeOf((*MockSearchServiceInterface)(nil).UsersByGroup), varargs...)
	return &MockSearchServiceInterfaceUsersByGroupCall{Call: call}
}

// MockSearchServiceInterfaceUsersByGroupCall wrap *gomock.Call
type MockSearchServiceInterfaceUsersByGroupCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceUsersByGroupCall) Return(arg0 []*gitlab.User, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceUsersByGroupCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceUsersByGroupCall) Do(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error)) *MockSearchServiceInterfaceUsersByGroupCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceUsersByGroupCall) DoAndReturn(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error)) *MockSearchServiceInterfaceUsersByGroupCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UsersByProject mocks base method.
func (m *MockSearchServiceInterface) UsersByProject(pid any, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UsersByProject", varargs...)
	ret0, _ := ret[0].([]*gitlab.User)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// UsersByProject indicates an expected call of UsersByProject.
func (mr *MockSearchServiceInterfaceMockRecorder) UsersByProject(pid, query, opt any, options ...any) *MockSearchServiceInterfaceUsersByProjectCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UsersByProject", reflect.TypeOf((*MockSearchServiceInterface)(nil).UsersByProject), varargs...)
	return &MockSearchServiceInterfaceUsersByProjectCall{Call: call}
}

// MockSearchServiceInterfaceUsersByProjectCall wrap *gomock.Call
type MockSearchServiceInterfaceUsersByProjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceUsersByProjectCall) Return(arg0 []*gitlab.User, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceUsersByProjectCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceUsersByProjectCall) Do(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error)) *MockSearchServiceInterfaceUsersByProjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceUsersByProjectCall) DoAndReturn(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error)) *MockSearchServiceInterfaceUsersByProjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// WikiBlobs mocks base method.
func (m *MockSearchServiceInterface) WikiBlobs(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Wiki, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WikiBlobs", varargs...)
	ret0, _ := ret[0].([]*gitlab.Wiki)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// WikiBlobs indicates an expected call of WikiBlobs.
func (mr *MockSearchServiceInterfaceMockRecorder) WikiBlobs(query, opt any, options ...any) *MockSearchServiceInterfaceWikiBlobsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WikiBlobs", reflect.TypeOf((*MockSearchServiceInterface)(nil).WikiBlobs), varargs...)
	return &MockSearchServiceInterfaceWikiBlobsCall{Call: call}
}

// MockSearchServiceInterfaceWikiBlobsCall wrap *gomock.Call
type MockSearchServiceInterfaceWikiBlobsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceWikiBlobsCall) Return(arg0 []*gitlab.Wiki, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceWikiBlobsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceWikiBlobsCall) Do(f func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Wiki, *gitlab.Response, error)) *MockSearchServiceInterfaceWikiBlobsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceWikiBlobsCall) DoAndReturn(f func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Wiki, *gitlab.Response, error)) *MockSearchServiceInterfaceWikiBlobsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// WikiBlobsByGroup mocks base method.
func (m *MockSearchServiceInterface) WikiBlobsByGroup(gid any, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Wiki, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{gid, query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WikiBlobsByGroup", varargs...)
	ret0, _ := ret[0].([]*gitlab.Wiki)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// WikiBlobsByGroup indicates an expected call of WikiBlobsByGroup.
func (mr *MockSearchServiceInterfaceMockRecorder) WikiBlobsByGroup(gid, query, opt any, options ...any) *MockSearchServiceInterfaceWikiBlobsByGroupCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{gid, query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WikiBlobsByGroup", reflect.TypeOf((*MockSearchServiceInterface)(nil).WikiBlobsByGroup), varargs...)
	return &MockSearchServiceInterfaceWikiBlobsByGroupCall{Call: call}
}

// MockSearchServiceInterfaceWikiBlobsByGroupCall wrap *gomock.Call
type MockSearchServiceInterfaceWikiBlobsByGroupCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceWikiBlobsByGroupCall) Return(arg0 []*gitlab.Wiki, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceWikiBlobsByGroupCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceWikiBlobsByGroupCall) Do(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Wiki, *gitlab.Response, error)) *MockSearchServiceInterfaceWikiBlobsByGroupCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceWikiBlobsByGroupCall) DoAndReturn(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Wiki, *gitlab.Response, error)) *MockSearchServiceInterfaceWikiBlobsByGroupCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// WikiBlobsByProject mocks base method.
func (m *MockSearchServiceInterface) WikiBlobsByProject(pid any, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Wiki, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, query, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WikiBlobsByProject", varargs...)
	ret0, _ := ret[0].([]*gitlab.Wiki)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// WikiBlobsByProject indicates an expected call of WikiBlobsByProject.
func (mr *MockSearchServiceInterfaceMockRecorder) WikiBlobsByProject(pid, query, opt any, options ...any) *MockSearchServiceInterfaceWikiBlobsByProjectCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, query, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WikiBlobsByProject", reflect.TypeOf((*MockSearchServiceInterface)(nil).WikiBlobsByProject), varargs...)
	return &MockSearchServiceInterfaceWikiBlobsByProjectCall{Call: call}
}

// MockSearchServiceInterfaceWikiBlobsByProjectCall wrap *gomock.Call
type MockSearchServiceInterfaceWikiBlobsByProjectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSearchServiceInterfaceWikiBlobsByProjectCall) Return(arg0 []*gitlab.Wiki, arg1 *gitlab.Response, arg2 error) *MockSearchServiceInterfaceWikiBlobsByProjectCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSearchServiceInterfaceWikiBlobsByProjectCall) Do(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Wiki, *gitlab.Response, error)) *MockSearchServiceInterfaceWikiBlobsByProjectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSearchServiceInterfaceWikiBlobsByProjectCall) DoAndReturn(f func(any, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Wiki, *gitlab.Response, error)) *MockSearchServiceInterfaceWikiBlobsByProjectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
