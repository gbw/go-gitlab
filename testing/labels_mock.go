// Code generated by MockGen. DO NOT EDIT.
// Source: gitlab.com/gitlab-org/api/client-go (interfaces: LabelsServiceInterface)
//
// Generated by this command:
//
//	mockgen -typed -destination=labels_mock.go -write_package_comment=false -package=testing gitlab.com/gitlab-org/api/client-go LabelsServiceInterface
//

package testing

import (
	reflect "reflect"

	gitlab "gitlab.com/gitlab-org/api/client-go"
	gomock "go.uber.org/mock/gomock"
)

// MockLabelsServiceInterface is a mock of LabelsServiceInterface interface.
type MockLabelsServiceInterface struct {
	ctrl     *gomock.Controller
	recorder *MockLabelsServiceInterfaceMockRecorder
	isgomock struct{}
}

// MockLabelsServiceInterfaceMockRecorder is the mock recorder for MockLabelsServiceInterface.
type MockLabelsServiceInterfaceMockRecorder struct {
	mock *MockLabelsServiceInterface
}

// NewMockLabelsServiceInterface creates a new mock instance.
func NewMockLabelsServiceInterface(ctrl *gomock.Controller) *MockLabelsServiceInterface {
	mock := &MockLabelsServiceInterface{ctrl: ctrl}
	mock.recorder = &MockLabelsServiceInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLabelsServiceInterface) EXPECT() *MockLabelsServiceInterfaceMockRecorder {
	return m.recorder
}

// CreateLabel mocks base method.
func (m *MockLabelsServiceInterface) CreateLabel(pid any, opt *gitlab.CreateLabelOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Label, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateLabel", varargs...)
	ret0, _ := ret[0].(*gitlab.Label)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreateLabel indicates an expected call of CreateLabel.
func (mr *MockLabelsServiceInterfaceMockRecorder) CreateLabel(pid, opt any, options ...any) *MockLabelsServiceInterfaceCreateLabelCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateLabel", reflect.TypeOf((*MockLabelsServiceInterface)(nil).CreateLabel), varargs...)
	return &MockLabelsServiceInterfaceCreateLabelCall{Call: call}
}

// MockLabelsServiceInterfaceCreateLabelCall wrap *gomock.Call
type MockLabelsServiceInterfaceCreateLabelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLabelsServiceInterfaceCreateLabelCall) Return(arg0 *gitlab.Label, arg1 *gitlab.Response, arg2 error) *MockLabelsServiceInterfaceCreateLabelCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLabelsServiceInterfaceCreateLabelCall) Do(f func(any, *gitlab.CreateLabelOptions, ...gitlab.RequestOptionFunc) (*gitlab.Label, *gitlab.Response, error)) *MockLabelsServiceInterfaceCreateLabelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLabelsServiceInterfaceCreateLabelCall) DoAndReturn(f func(any, *gitlab.CreateLabelOptions, ...gitlab.RequestOptionFunc) (*gitlab.Label, *gitlab.Response, error)) *MockLabelsServiceInterfaceCreateLabelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteLabel mocks base method.
func (m *MockLabelsServiceInterface) DeleteLabel(pid, lid any, opt *gitlab.DeleteLabelOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, lid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteLabel", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteLabel indicates an expected call of DeleteLabel.
func (mr *MockLabelsServiceInterfaceMockRecorder) DeleteLabel(pid, lid, opt any, options ...any) *MockLabelsServiceInterfaceDeleteLabelCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, lid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteLabel", reflect.TypeOf((*MockLabelsServiceInterface)(nil).DeleteLabel), varargs...)
	return &MockLabelsServiceInterfaceDeleteLabelCall{Call: call}
}

// MockLabelsServiceInterfaceDeleteLabelCall wrap *gomock.Call
type MockLabelsServiceInterfaceDeleteLabelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLabelsServiceInterfaceDeleteLabelCall) Return(arg0 *gitlab.Response, arg1 error) *MockLabelsServiceInterfaceDeleteLabelCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLabelsServiceInterfaceDeleteLabelCall) Do(f func(any, any, *gitlab.DeleteLabelOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockLabelsServiceInterfaceDeleteLabelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLabelsServiceInterfaceDeleteLabelCall) DoAndReturn(f func(any, any, *gitlab.DeleteLabelOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockLabelsServiceInterfaceDeleteLabelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetLabel mocks base method.
func (m *MockLabelsServiceInterface) GetLabel(pid, lid any, options ...gitlab.RequestOptionFunc) (*gitlab.Label, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, lid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetLabel", varargs...)
	ret0, _ := ret[0].(*gitlab.Label)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetLabel indicates an expected call of GetLabel.
func (mr *MockLabelsServiceInterfaceMockRecorder) GetLabel(pid, lid any, options ...any) *MockLabelsServiceInterfaceGetLabelCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, lid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLabel", reflect.TypeOf((*MockLabelsServiceInterface)(nil).GetLabel), varargs...)
	return &MockLabelsServiceInterfaceGetLabelCall{Call: call}
}

// MockLabelsServiceInterfaceGetLabelCall wrap *gomock.Call
type MockLabelsServiceInterfaceGetLabelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLabelsServiceInterfaceGetLabelCall) Return(arg0 *gitlab.Label, arg1 *gitlab.Response, arg2 error) *MockLabelsServiceInterfaceGetLabelCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLabelsServiceInterfaceGetLabelCall) Do(f func(any, any, ...gitlab.RequestOptionFunc) (*gitlab.Label, *gitlab.Response, error)) *MockLabelsServiceInterfaceGetLabelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLabelsServiceInterfaceGetLabelCall) DoAndReturn(f func(any, any, ...gitlab.RequestOptionFunc) (*gitlab.Label, *gitlab.Response, error)) *MockLabelsServiceInterfaceGetLabelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListLabels mocks base method.
func (m *MockLabelsServiceInterface) ListLabels(pid any, opt *gitlab.ListLabelsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Label, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListLabels", varargs...)
	ret0, _ := ret[0].([]*gitlab.Label)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListLabels indicates an expected call of ListLabels.
func (mr *MockLabelsServiceInterfaceMockRecorder) ListLabels(pid, opt any, options ...any) *MockLabelsServiceInterfaceListLabelsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListLabels", reflect.TypeOf((*MockLabelsServiceInterface)(nil).ListLabels), varargs...)
	return &MockLabelsServiceInterfaceListLabelsCall{Call: call}
}

// MockLabelsServiceInterfaceListLabelsCall wrap *gomock.Call
type MockLabelsServiceInterfaceListLabelsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLabelsServiceInterfaceListLabelsCall) Return(arg0 []*gitlab.Label, arg1 *gitlab.Response, arg2 error) *MockLabelsServiceInterfaceListLabelsCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLabelsServiceInterfaceListLabelsCall) Do(f func(any, *gitlab.ListLabelsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Label, *gitlab.Response, error)) *MockLabelsServiceInterfaceListLabelsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLabelsServiceInterfaceListLabelsCall) DoAndReturn(f func(any, *gitlab.ListLabelsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Label, *gitlab.Response, error)) *MockLabelsServiceInterfaceListLabelsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PromoteLabel mocks base method.
func (m *MockLabelsServiceInterface) PromoteLabel(pid, lid any, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, lid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PromoteLabel", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PromoteLabel indicates an expected call of PromoteLabel.
func (mr *MockLabelsServiceInterfaceMockRecorder) PromoteLabel(pid, lid any, options ...any) *MockLabelsServiceInterfacePromoteLabelCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, lid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PromoteLabel", reflect.TypeOf((*MockLabelsServiceInterface)(nil).PromoteLabel), varargs...)
	return &MockLabelsServiceInterfacePromoteLabelCall{Call: call}
}

// MockLabelsServiceInterfacePromoteLabelCall wrap *gomock.Call
type MockLabelsServiceInterfacePromoteLabelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLabelsServiceInterfacePromoteLabelCall) Return(arg0 *gitlab.Response, arg1 error) *MockLabelsServiceInterfacePromoteLabelCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLabelsServiceInterfacePromoteLabelCall) Do(f func(any, any, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockLabelsServiceInterfacePromoteLabelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLabelsServiceInterfacePromoteLabelCall) DoAndReturn(f func(any, any, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockLabelsServiceInterfacePromoteLabelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SubscribeToLabel mocks base method.
func (m *MockLabelsServiceInterface) SubscribeToLabel(pid, lid any, options ...gitlab.RequestOptionFunc) (*gitlab.Label, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, lid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubscribeToLabel", varargs...)
	ret0, _ := ret[0].(*gitlab.Label)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// SubscribeToLabel indicates an expected call of SubscribeToLabel.
func (mr *MockLabelsServiceInterfaceMockRecorder) SubscribeToLabel(pid, lid any, options ...any) *MockLabelsServiceInterfaceSubscribeToLabelCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, lid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribeToLabel", reflect.TypeOf((*MockLabelsServiceInterface)(nil).SubscribeToLabel), varargs...)
	return &MockLabelsServiceInterfaceSubscribeToLabelCall{Call: call}
}

// MockLabelsServiceInterfaceSubscribeToLabelCall wrap *gomock.Call
type MockLabelsServiceInterfaceSubscribeToLabelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLabelsServiceInterfaceSubscribeToLabelCall) Return(arg0 *gitlab.Label, arg1 *gitlab.Response, arg2 error) *MockLabelsServiceInterfaceSubscribeToLabelCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLabelsServiceInterfaceSubscribeToLabelCall) Do(f func(any, any, ...gitlab.RequestOptionFunc) (*gitlab.Label, *gitlab.Response, error)) *MockLabelsServiceInterfaceSubscribeToLabelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLabelsServiceInterfaceSubscribeToLabelCall) DoAndReturn(f func(any, any, ...gitlab.RequestOptionFunc) (*gitlab.Label, *gitlab.Response, error)) *MockLabelsServiceInterfaceSubscribeToLabelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UnsubscribeFromLabel mocks base method.
func (m *MockLabelsServiceInterface) UnsubscribeFromLabel(pid, lid any, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, lid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UnsubscribeFromLabel", varargs...)
	ret0, _ := ret[0].(*gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UnsubscribeFromLabel indicates an expected call of UnsubscribeFromLabel.
func (mr *MockLabelsServiceInterfaceMockRecorder) UnsubscribeFromLabel(pid, lid any, options ...any) *MockLabelsServiceInterfaceUnsubscribeFromLabelCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, lid}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnsubscribeFromLabel", reflect.TypeOf((*MockLabelsServiceInterface)(nil).UnsubscribeFromLabel), varargs...)
	return &MockLabelsServiceInterfaceUnsubscribeFromLabelCall{Call: call}
}

// MockLabelsServiceInterfaceUnsubscribeFromLabelCall wrap *gomock.Call
type MockLabelsServiceInterfaceUnsubscribeFromLabelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLabelsServiceInterfaceUnsubscribeFromLabelCall) Return(arg0 *gitlab.Response, arg1 error) *MockLabelsServiceInterfaceUnsubscribeFromLabelCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLabelsServiceInterfaceUnsubscribeFromLabelCall) Do(f func(any, any, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockLabelsServiceInterfaceUnsubscribeFromLabelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLabelsServiceInterfaceUnsubscribeFromLabelCall) DoAndReturn(f func(any, any, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MockLabelsServiceInterfaceUnsubscribeFromLabelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateLabel mocks base method.
func (m *MockLabelsServiceInterface) UpdateLabel(pid, lid any, opt *gitlab.UpdateLabelOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Label, *gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []any{pid, lid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateLabel", varargs...)
	ret0, _ := ret[0].(*gitlab.Label)
	ret1, _ := ret[1].(*gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// UpdateLabel indicates an expected call of UpdateLabel.
func (mr *MockLabelsServiceInterfaceMockRecorder) UpdateLabel(pid, lid, opt any, options ...any) *MockLabelsServiceInterfaceUpdateLabelCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{pid, lid, opt}, options...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateLabel", reflect.TypeOf((*MockLabelsServiceInterface)(nil).UpdateLabel), varargs...)
	return &MockLabelsServiceInterfaceUpdateLabelCall{Call: call}
}

// MockLabelsServiceInterfaceUpdateLabelCall wrap *gomock.Call
type MockLabelsServiceInterfaceUpdateLabelCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLabelsServiceInterfaceUpdateLabelCall) Return(arg0 *gitlab.Label, arg1 *gitlab.Response, arg2 error) *MockLabelsServiceInterfaceUpdateLabelCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLabelsServiceInterfaceUpdateLabelCall) Do(f func(any, any, *gitlab.UpdateLabelOptions, ...gitlab.RequestOptionFunc) (*gitlab.Label, *gitlab.Response, error)) *MockLabelsServiceInterfaceUpdateLabelCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLabelsServiceInterfaceUpdateLabelCall) DoAndReturn(f func(any, any, *gitlab.UpdateLabelOptions, ...gitlab.RequestOptionFunc) (*gitlab.Label, *gitlab.Response, error)) *MockLabelsServiceInterfaceUpdateLabelCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
